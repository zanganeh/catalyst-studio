# Story 7.3: Implement Three-Layer Type System

## Status
Approved

## Estimation
3-5 days

## Story
**As a** developer,  
**I want** to implement the three-layer type system (primitives, common, extensions),  
**so that** content types can be defined in a platform-agnostic way.

## Acceptance Criteria
1. Primitive types defined and documented
2. Common patterns layer implemented with transformations
3. Platform extensions structure created
4. Field type compatibility matrix implemented
5. Fallback strategies defined for each type

## Definition of Done
- [ ] All primitive types implemented with 100% test coverage
- [ ] All common patterns transformable with confidence scores
- [ ] Compatibility matrix covers all 4 target platforms
- [ ] Performance benchmarks met (<10ms, <50ms, <100ms)
- [ ] Documentation complete and reviewed
- [ ] Integration tests passing with OptimizelyProvider
- [ ] No TypeScript errors with strict mode
- [ ] PR approved by tech lead

## Success Metrics
- 80%+ field type mapping success rate achieved
- All 7 primitive types fully functional
- All 8 common patterns implemented
- 5 fallback strategies operational
- Zero regression in existing functionality

## Risks & Mitigations
- **Risk**: Type system too rigid for future platforms
  - **Mitigation**: Extension mechanism allows platform-specific additions
- **Risk**: Performance degradation with complex transformations
  - **Mitigation**: Caching and memoization strategies implemented
- **Risk**: Breaking changes to existing types
  - **Mitigation**: All existing types tested for backward compatibility

## Tasks / Subtasks
- [ ] Git Setup (REQUIRED FIRST TASK)
  - [ ] Checkout and update main: `git checkout main && git pull origin main`
  - [ ] Create feature branch: `git checkout -b feature/epic7-type-system`

- [ ] Define Primitive Type Layer (AC: 1)
  - [ ] Create `lib/providers/universal/types/primitives.ts`:
    - [ ] Define PrimitiveType enum with base types
    - [ ] Create primitive type interfaces:
      - [ ] TextPrimitive (short text, max 255 chars)
      - [ ] LongTextPrimitive (long text, unlimited)
      - [ ] NumberPrimitive (integer/float)
      - [ ] BooleanPrimitive (true/false)
      - [ ] DatePrimitive (date/datetime)
      - [ ] JsonPrimitive (JSON data)
      - [ ] DecimalPrimitive (high-precision numbers)
    - [ ] Define validation rules for each primitive
    - [ ] Create type guards for primitive detection
  - [ ] Document each primitive type with:
    - [ ] Description and use cases
    - [ ] Platform compatibility notes
    - [ ] Example values and constraints
    - [ ] Default values

- [ ] Implement Common Patterns Layer (AC: 2)
  - [ ] Create `lib/providers/universal/types/common-patterns.ts`:
    - [ ] Define CommonPattern enum with pattern types
    - [ ] Create common pattern interfaces:
      - [ ] RichTextPattern (formatted text with markup)
      - [ ] MediaPattern (images, videos, files)
      - [ ] CollectionPattern (arrays of items)
      - [ ] ComponentPattern (reusable content blocks)
      - [ ] SelectPattern (dropdown/radio options)
      - [ ] RepeaterPattern (dynamic lists)
      - [ ] SlugPattern (URL-friendly identifiers)
      - [ ] TagsPattern (categorization labels)
    - [ ] Define transformation rules from primitives
    - [ ] Create pattern composition utilities
  - [ ] Implement pattern transformations in `lib/providers/universal/transformers/pattern-transformer.ts`:
    - [ ] Transform complex patterns to primitive fallbacks
    - [ ] Handle nested pattern structures
    - [ ] Generate confidence scores for transformations
    - [ ] Document degradation strategies

- [ ] Create Platform Extensions Structure (AC: 3)
  - [ ] Create `lib/providers/universal/types/extensions.ts`:
    - [ ] Define PlatformExtension interface
    - [ ] Create extension registry mechanism
    - [ ] Implement extension validation
    - [ ] Define extension metadata structure
  - [ ] Create extension directories for each platform:
    - [ ] Create `lib/providers/universal/extensions/optimizely/`:
      - [ ] Define Optimizely-specific extensions
      - [ ] Document Optimizely unique features
      - [ ] Create mapping to/from universal types
    - [ ] Create `lib/providers/universal/extensions/contentful/` (POST-MVP placeholder):
      - [ ] Define structure for future Contentful extensions
      - [ ] Add README with expected extensions
    - [ ] Create `lib/providers/universal/extensions/strapi/` (POST-MVP placeholder):
      - [ ] Define structure for future Strapi extensions
      - [ ] Add README with expected extensions
    - [ ] Create `lib/providers/universal/extensions/sanity/` (POST-MVP placeholder):
      - [ ] Define structure for future Sanity extensions
      - [ ] Add README with expected extensions
  - [ ] Implement extension loader in `lib/providers/universal/extensions/loader.ts`:
    - [ ] Dynamic extension loading based on provider
    - [ ] Extension capability detection
    - [ ] Extension conflict resolution

- [ ] Build Field Type Compatibility Matrix (AC: 4)
  - [ ] Create `lib/providers/universal/compatibility/matrix.ts`:
    - [ ] Define CompatibilityMatrix interface
    - [ ] Create platform capability mappings:
      - [ ] Optimizely field type mappings
      - [ ] Contentful field type mappings (from research)
      - [ ] Strapi field type mappings (from research)
      - [ ] Sanity field type mappings (from research)
    - [ ] Implement compatibility scoring algorithm:
      - [ ] Calculate type compatibility (0-100)
      - [ ] Identify required transformations
      - [ ] Detect potential data loss
      - [ ] Generate migration warnings
  - [ ] Create `lib/providers/universal/compatibility/field-mapper.ts`:
    - [ ] Map universal types to platform-specific types
    - [ ] Handle type conversions with confidence scores
    - [ ] Implement bidirectional mapping
    - [ ] Create mapping documentation
  - [ ] Build compatibility database in `lib/providers/universal/compatibility/database.json`:
    - [ ] Document all known field type mappings
    - [ ] Include transformation examples
    - [ ] List platform limitations
    - [ ] Provide migration guidelines

- [ ] Define Fallback Strategies (AC: 5)
  - [ ] Create `lib/providers/universal/fallback/strategies.ts`:
    - [ ] Define FallbackStrategy enum:
      - [ ] BEST_MATCH: Find closest compatible type
      - [ ] FLATTEN: Convert to simpler type
      - [ ] PRESERVE: Keep as JSON/text with metadata
      - [ ] DOCUMENT: Add migration notes
      - [ ] REJECT: Fail with clear error
    - [ ] Implement strategy selection logic
    - [ ] Create fallback execution engine
  - [ ] Implement specific fallback handlers in `lib/providers/universal/fallback/handlers/`:
    - [ ] Create `rich-text-fallback.ts`:
      - [ ] RichText → Markdown conversion
      - [ ] RichText → Plain text extraction
      - [ ] Preserve formatting metadata
    - [ ] Create `media-fallback.ts`:
      - [ ] Media → URL string conversion
      - [ ] Metadata preservation in JSON
      - [ ] Alternative text handling
    - [ ] Create `component-fallback.ts`:
      - [ ] Component → JSON structure
      - [ ] Nested component flattening
      - [ ] Reference preservation
    - [ ] Create `collection-fallback.ts`:
      - [ ] Collection → JSON array
      - [ ] Item type preservation
      - [ ] Ordering maintenance
  - [ ] Document fallback strategies in `lib/providers/universal/fallback/README.md`:
    - [ ] When each strategy applies
    - [ ] Data preservation guarantees
    - [ ] Recovery procedures
    - [ ] Examples of each fallback

- [ ] Create Type System Utilities (AC: 1-5)
  - [ ] Create `lib/providers/universal/utils/type-detector.ts`:
    - [ ] Auto-detect type from data
    - [ ] Suggest best universal type
    - [ ] Validate type assignments
  - [ ] Create `lib/providers/universal/utils/type-converter.ts`:
    - [ ] Convert between type layers
    - [ ] Handle type composition
    - [ ] Manage type inheritance
  - [ ] Create `lib/providers/universal/utils/type-validator.ts`:
    - [ ] Validate universal type definitions
    - [ ] Check type consistency
    - [ ] Ensure platform compatibility
  - [ ] Create `lib/providers/universal/utils/confidence-scorer.ts`:
    - [ ] Calculate transformation confidence
    - [ ] Score based on data loss potential
    - [ ] Consider platform capabilities

- [ ] Implement Type System Integration (AC: 2, 4)
  - [ ] Update `lib/providers/universal/UniversalContentType.ts`:
    - [ ] Use three-layer type system
    - [ ] Add type layer metadata
    - [ ] Include compatibility scores
  - [ ] Update `lib/providers/universal/UniversalField.ts`:
    - [ ] Reference primitive/common/extension types
    - [ ] Add fallback strategy preferences
    - [ ] Include transformation metadata
  - [ ] Create `lib/providers/universal/TypeSystemManager.ts`:
    - [ ] Central type system coordinator
    - [ ] Type registration and discovery
    - [ ] Type transformation orchestration

- [ ] Add Type System Tests
  - [ ] Create `lib/providers/universal/types/__tests__/`:
    - [ ] Test primitive type definitions
    - [ ] Test type guards and validators
    - [ ] Test default values
  - [ ] Create `lib/providers/universal/types/__tests__/primitives.test.ts`:
    - [ ] Test each primitive type
    - [ ] Test validation rules
    - [ ] Test edge cases
  - [ ] Create `lib/providers/universal/types/__tests__/common-patterns.test.ts`:
    - [ ] Test pattern definitions
    - [ ] Test pattern transformations
    - [ ] Test pattern composition
  - [ ] Create `lib/providers/universal/compatibility/__tests__/matrix.test.ts`:
    - [ ] Test compatibility calculations
    - [ ] Test platform mappings
    - [ ] Test confidence scoring
  - [ ] Create `lib/providers/universal/fallback/__tests__/strategies.test.ts`:
    - [ ] Test each fallback strategy
    - [ ] Test strategy selection
    - [ ] Test data preservation

- [ ] Create Type System Documentation
  - [ ] Create `lib/providers/universal/types/README.md`:
    - [ ] Explain three-layer architecture
    - [ ] Document each type in detail
    - [ ] Provide usage examples
    - [ ] Include migration guide
  - [ ] Create `lib/providers/universal/compatibility/COMPATIBILITY.md`:
    - [ ] Platform compatibility matrix
    - [ ] Transformation confidence table
    - [ ] Known limitations per platform
    - [ ] Best practices for type selection
  - [ ] Update `docs/epic7-type-system-guide.md`:
    - [ ] Complete type system reference
    - [ ] Developer usage guide
    - [ ] AI generation guidelines
    - [ ] Troubleshooting common issues

- [ ] Performance Optimization
  - [ ] Profile type transformation performance:
    - [ ] Measure primitive transformations
    - [ ] Measure pattern transformations
    - [ ] Measure compatibility calculations
  - [ ] Optimize hot paths:
    - [ ] Cache compatibility scores
    - [ ] Memoize type transformations
    - [ ] Lazy-load platform extensions
  - [ ] Target benchmarks:
    - [ ] < 10ms for primitive transformations
    - [ ] < 50ms for pattern transformations
    - [ ] < 100ms for full type compatibility check

- [ ] Integration Testing (AC: 1-5)
  - [ ] Test with OptimizelyProvider:
    - [ ] Transform Optimizely types to universal
    - [ ] Apply fallback strategies
    - [ ] Verify round-trip accuracy
  - [ ] Test with MockProvider:
    - [ ] Generate types using three-layer system
    - [ ] Validate type consistency
    - [ ] Test edge cases
  - [ ] Create integration test scenarios:
    - [ ] Complex nested types
    - [ ] Platform-specific extensions
    - [ ] Fallback strategy execution
    - [ ] Confidence score accuracy

- [ ] Submit PR (REQUIRED FINAL TASK)
  - [ ] Push branch: `git push -u origin feature/epic7-type-system`
  - [ ] Create PR from feature branch → main branch
  - [ ] PR Title: "Epic 7 Story 7.3: Implement Three-Layer Type System"
  - [ ] Link PR to story in description

## Dev Notes

### GitFlow Workflow
Branch Name: feature/epic7-type-system
Base Branch: main
PR Target: main

Git Commands:
1. Setup: `git checkout main && git pull origin main`
2. Create: `git checkout -b feature/epic7-type-system`
3. Commit: Use conventional commits (feat:, fix:, docs:, etc.)
4. Push: `git push -u origin feature/epic7-type-system`
5. PR: Create PR to main branch with title "Epic 7 Story 7.3: Implement Three-Layer Type System"

### Previous Story Context (Story 7.2)
**Optimizely Provider Created**:
- OptimizelyProvider implementing ICMSProvider
- All Optimizely logic encapsulated in provider module
- Mapping layer for Universal ↔ Optimizely types
- Clean separation from application code

**This story builds on that** by implementing the core three-layer type system that all providers will use.

### Type System Architecture

**Three-Layer Hierarchy** [Source: epic7-prd.md#Three-Layer Type System]:
1. **Primitives** (Layer 1): Universal basic types that all platforms support
2. **Common Patterns** (Layer 2): Composed types built from primitives
3. **Platform Extensions** (Layer 3): Platform-specific features isolated

**Type Transformation Flow**:
```
Platform Type → Universal Type → Three-Layer Classification → Target Platform Type
                                            ↓
                                   Fallback if incompatible
```

### Primitive Types Reference

**Layer 1: Universal Primitives** [Source: epic7-prd.md#Appendix A]:
- `text`: Short text (max 255 characters)
- `longText`: Long text (unlimited)
- `number`: Integer or floating point
- `boolean`: True/false value
- `date`: Date/datetime value
- `json`: Arbitrary JSON data
- `decimal`: High-precision decimal numbers

### Common Patterns Reference

**Layer 2: Common Patterns** [Source: epic7-prd.md#Appendix A]:
- `richText`: Formatted text with markup
- `media`: Images, videos, files with metadata
- `collection`: Arrays of typed items
- `component`: Reusable content blocks
- `select`: Dropdown/radio selections
- `repeater`: Dynamic lists of fields
- `slug`: URL-friendly identifiers
- `tags`: Categorization labels

### Platform Extensions Reference

**Layer 3: Platform-Specific** [Source: epic7-prd.md#Platform Extensions]:
- Isolated in platform-specific directories
- Not used in universal definitions
- Documented with migration paths
- Include confidence scores for transformation

### Compatibility Matrix Structure

**Platform Capability Matrix** [Source: epic7-prd.md#Appendix B]:
| CMS Platform | Pages | Components | Dynamic Areas | Nested Components | Max Depth |
|-------------|-------|------------|---------------|-------------------|-----------|
| Strapi | Collection/Single Types | Components | Dynamic Zones | ✅ (limited) | Unlimited |
| Contentful | Entries with URLs | Modular Blocks | Reference Fields | ✅ | 10 levels |
| Sanity | Documents w/ Routes | Portable Text | Arrays | ✅ | Unlimited |
| Optimizely | Pages (Routable) | Blocks | Content Areas | ✅ | Unlimited |

### Fallback Strategy Guidelines

**Strategy Selection** [Source: epic7-prd.md#FR9]:
1. **BEST_MATCH**: Default strategy, find closest compatible type
2. **FLATTEN**: Simplify complex types to basic equivalents
3. **PRESERVE**: Keep as JSON with full metadata
4. **DOCUMENT**: Add detailed migration notes
5. **REJECT**: Fail fast with clear error message

**Confidence Scoring** [Source: epic7-prd.md#FR8]:
- 90-100: Perfect compatibility, no data loss
- 70-89: Good compatibility, minor adjustments
- 50-69: Partial compatibility, some features lost
- 0-49: Poor compatibility, significant data loss

### Testing Requirements

**Test Coverage Targets**:
- Primitive types: 100% coverage
- Common patterns: 95% coverage
- Fallback strategies: 90% coverage
- Compatibility matrix: 85% coverage

**Performance Benchmarks**:
- Type detection: < 5ms
- Primitive transformation: < 10ms
- Pattern transformation: < 50ms
- Full compatibility check: < 100ms

### Implementation Priority

1. **Core Types First**: Implement primitives before patterns
2. **Optimizely Focus**: Complete Optimizely extensions first
3. **Fallback Safety**: Ensure all types have fallback strategies
4. **Documentation**: Document as you implement

### Important Considerations

- **Backward Compatibility**: Ensure existing types can be represented
- **Forward Compatibility**: Design for future platform additions
- **Type Safety**: Use TypeScript strict mode throughout
- **Performance**: Cache transformations where possible
- **Validation**: Every type must be validatable

### AI Integration Notes

**For AI System Prompts** [Source: epic7-prd.md#AI Generation Guidelines]:
- Types should be self-documenting
- Include examples in type definitions
- Provide clear transformation rules
- Document confidence thresholds

### Dependencies

**Required Before This Story**:
- Story 7.1: Provider foundation (✅ Complete)
- Story 7.2: OptimizelyProvider (Must be merged first)

**Enables Future Stories**:
- Story 7.4: AI System Integration
- Story 7.5: Migration Engine

### Integration Points with Story 7.2

**OptimizelyProvider Integration**:
- OptimizelyProvider will use the three-layer type system for transformations
- Type mapper in OptimizelyProvider (`lib/providers/optimizely/mappers/type-mapper.ts`) will call:
  - `TypeSystemManager` for type classification
  - `CompatibilityMatrix` for platform capability checks
  - `FallbackStrategy` handlers for incompatible types
- Integration tests must verify:
  - OptimizelyProvider can transform native types to universal format
  - Universal types can be converted back to Optimizely format
  - Confidence scores are correctly calculated
  - Fallback strategies work as expected

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-19 | 1.0 | Initial story creation based on PRD | Assistant |
| 2025-01-19 | 1.1 | Applied PO validation feedback: Added DoD, Success Metrics, Risks, clarified MVP scope, added integration points | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be filled by Dev Agent]

### Debug Log References
[To be filled by Dev Agent]

### Completion Notes List
[To be filled by Dev Agent]

### File List
[To be filled by Dev Agent]

## QA Results
[To be filled by QA Agent]