# Story 8.4: Site Structure Service Layer

## Status
Approved

## Story Metadata
- **Epic**: Epic 8 - AI-Powered Site Structure Generation
- **Story ID**: 8.4
- **Story Points**: 5
- **Priority**: P0 (Critical)
- **Dependencies**: Story 8.1 (Database Schema), Story 8.2 (Slug Management), Story 8.3 (Page Orchestration API)
- **Risk Level**: Medium (Core service layer for tree operations)
- **Estimated Duration**: 2 days

## Story

**As a** developer,
**I want** a comprehensive Site Structure Service Layer that handles all tree operations and path management,
**So that** I can perform complex hierarchical operations like tree traversal, path recalculation, and bulk operations efficiently.

## Background & Context

Following the Page Orchestration API implementation (8.3), we need to implement the Site Structure Service Layer that provides all the tree manipulation operations, path management utilities, and validation logic required for managing hierarchical site structures. This service will be used by the Page Orchestrator and other components that need to work with the site hierarchy.

### Key Architectural Requirements
The Site Structure Service handles operations at the structure level, separate from content management. It provides:
- Tree traversal operations (ancestors, descendants, siblings)
- Path management and recalculation
- Node moving with circular reference prevention
- Bulk operations for efficiency
- Tree validation and integrity checks

## Acceptance Criteria

1. [ ] SiteStructureService class implemented with all core methods
2. [ ] Tree traversal methods return correct hierarchical data
3. [ ] Path recalculation cascades properly to all descendants
4. [ ] Move operations prevent circular references
5. [ ] Bulk operations complete in < 1 second for 100 nodes
6. [ ] Tree integrity validation identifies orphaned nodes
7. [ ] Get tree operation returns complete hierarchy with proper nesting
8. [ ] Breadcrumb generation returns accurate ancestor chain
9. [ ] Position reordering maintains sequential order
10. [ ] All operations use proper database transactions
11. [ ] Unit tests with 85%+ coverage for service methods
12. [ ] Integration tests validating tree operations
13. [ ] TypeScript interfaces properly exported

## Tasks / Subtasks

- [ ] **Git Setup** (REQUIRED FIRST TASK)
  - [ ] Checkout and update main: `git checkout main && git pull origin main`
  - [ ] Create feature branch: `git checkout -b feature/8-4-site-structure-service`

- [ ] **Create Site Structure Service** (AC: 1, 10)
  - [ ] Create `lib/services/site-structure/site-structure-service.ts`
  - [ ] Implement `ISiteStructureService` interface with all methods
  - [ ] Add dependency injection for repository pattern
  - [ ] Integrate with existing page-orchestrator for shared logic

- [ ] **Implement Tree Traversal Methods** (AC: 2, 8)
  - [ ] `getTree(websiteId)`: Return complete tree structure
  - [ ] `getAncestors(nodeId)`: Get all parent nodes up to root
  - [ ] `getDescendants(nodeId)`: Get all child nodes recursively
  - [ ] `getSiblings(nodeId)`: Get nodes at same level
  - [ ] `getBreadcrumbs(nodeId)`: Generate breadcrumb trail

- [ ] **Implement Path Management** (AC: 3)
  - [ ] Create `lib/services/site-structure/path-manager.ts`
  - [ ] `buildPath(parentPath, slug)`: Construct full paths
  - [ ] `recalculatePaths(nodeId)`: Update all descendant paths
  - [ ] `getDepth(path)`: Calculate depth from path
  - [ ] Handle path updates in database transactions

- [ ] **Implement Move Operations** (AC: 4)
  - [ ] `moveNode(nodeId, newParentId)`: Change parent with validation
  - [ ] `validateMove(nodeId, targetParentId)`: Check for circular refs
  - [ ] `wouldCreateCycle(nodeId, targetParentId)`: Cycle detection
  - [ ] Update positions of affected siblings
  - [ ] Cascade path updates to descendants

- [ ] **Implement Position Management** (AC: 9)
  - [ ] `reorderSiblings(parentId, positions)`: Bulk position update
  - [ ] `insertAtPosition(nodeId, position)`: Insert with reordering
  - [ ] `swapPositions(nodeId1, nodeId2)`: Swap two nodes
  - [ ] Maintain sequential positions without gaps

- [ ] **Implement Bulk Operations** (AC: 5)
  - [ ] `bulkCreate(nodes)`: Create multiple nodes in transaction
  - [ ] `bulkUpdate(updates)`: Update multiple nodes efficiently
  - [ ] `bulkDelete(nodeIds)`: Delete with cascade handling
  - [ ] `bulkMove(moves)`: Move multiple nodes atomically
  - [ ] Optimize with raw SQL where appropriate

- [ ] **Implement Validation Methods** (AC: 6)
  - [ ] `validateTree(websiteId)`: Check tree integrity
  - [ ] `findOrphanedNodes(websiteId)`: Identify broken references
  - [ ] `validatePaths(websiteId)`: Verify path consistency
  - [ ] `repairTree(websiteId)`: Fix common issues
  - [ ] Return detailed validation report

- [ ] **Create Repository Pattern** (AC: 10)
  - [ ] Create `lib/services/site-structure/site-structure-repository.ts`
  - [ ] Implement data access methods using Prisma
  - [ ] Add caching layer preparation (interface only)
  - [ ] Handle transaction management

- [ ] **Add Service Integration** (AC: 1, 13)
  - [ ] Export service from index file
  - [ ] Create service factory/singleton pattern
  - [ ] Add to dependency injection container
  - [ ] Update Page Orchestrator to use new service

- [ ] **Write Unit Tests** (AC: 11)
  - [ ] Create `lib/services/site-structure/__tests__/site-structure-service.test.ts`
  - [ ] Test tree traversal methods
  - [ ] Test path management operations
  - [ ] Test move operations with edge cases
  - [ ] Test bulk operations performance
  - [ ] Mock Prisma for isolation

- [ ] **Write Integration Tests** (AC: 12)
  - [ ] Create `lib/services/site-structure/__tests__/site-structure-service.integration.test.ts`
  - [ ] Test complete tree operations with real database
  - [ ] Test transaction rollback on failures
  - [ ] Test concurrent operations
  - [ ] Performance test with 100+ nodes

- [ ] **Documentation** (AC: 13)
  - [ ] Add JSDoc comments to all public methods
  - [ ] Document tree operation complexity (Big O)
  - [ ] Create usage examples
  - [ ] Document transaction boundaries

- [ ] **Submit PR** (REQUIRED FINAL TASK)
  - [ ] Push branch: `git push -u origin feature/8-4-site-structure-service`
  - [ ] Create PR from feature branch → main branch
  - [ ] PR Title: "Epic 8 Story 8.4: Site Structure Service Layer"
  - [ ] Link PR to story in description

## Dev Notes

### ⚠️ CRITICAL IMPLEMENTATION NOTE
**Database Schema Adaptation from Story 8.3:**
The actual implemented database schema differs from the original architecture docs:
- Use `pathDepth` field (NOT `depth`)
- There is NO `materializedPath` field - use `fullPath` for path operations
- Parent chain traversal is done by walking up `parentId` references (see page-orchestrator.ts `getBreadcrumbs` method)
- The `weight` field exists but is currently just set to 0

### Previous Story Insights
From Story 8.3 (Page Orchestration API):
- PageOrchestrator is in `lib/services/site-structure/page-orchestrator.ts`
- Uses Prisma transactions with `$transaction` for atomicity
- Slug management utilities already available in `slug-manager.ts`
- Error classes defined in `lib/services/site-structure/errors.ts`
- Type definitions in `lib/types/page-orchestrator.types.ts`
- **Field names:** Implementation uses `pathDepth` not `depth`, no `materializedPath`

### Architecture Context

#### Service Layer Architecture
[Source: docs/epic8-brownfield-architecture.md#service-layer-architecture]
The SiteStructureService implements the ISiteStructureService interface:
```typescript
interface ISiteStructureService {
  generateFromRequirements(requirements: string): Promise<SiteStructure>;
  create(node: CreateNodeDto): Promise<SiteStructure>;
  update(id: string, updates: UpdateNodeDto): Promise<SiteStructure>;
  delete(id: string): Promise<void>;
  move(nodeId: string, newParentId: string): Promise<SiteStructure>;
  resolveUrl(path: string): Promise<SiteStructure>;
  getTree(websiteId: string): Promise<SiteStructure>;
}
```

#### Repository Pattern
[Source: docs/epic8-brownfield-architecture.md#repository-pattern]
```typescript
interface ISiteStructureRepository {
  findById(id: string): Promise<SiteStructure>;
  findByPath(path: string): Promise<SiteStructure>;
  findChildren(parentId: string): Promise<SiteStructure[]>;
  findAncestors(nodeId: string): Promise<SiteStructure[]>;
  save(node: SiteStructure): Promise<SiteStructure>;
  updatePaths(nodeId: string): Promise<void>;
  delete(id: string): Promise<void>;
}
```

#### Path Management Algorithm
[Source: docs/epic8-brownfield-architecture.md#path-management, adapted in Story 8.3]
- Full paths are constructed as: `${parentPath}/${slug}`
- Root nodes have paths like: `/slug`
- Path depth is calculated and stored in `pathDepth` field (NOT 'depth')
- **Note:** Materialized path concept from architecture was NOT implemented - parent chain traversal is done by walking up parentId references instead

#### Performance Requirements
[Source: docs/epic8-brownfield-prd.md#performance]
- URL resolution: < 10ms using indexed fullPath
- Bulk operations: < 1 second for 100 nodes
- Tree rendering: < 100ms for 500 nodes
- Use database indexes on: fullPath, parentId, websiteId, pathDepth

#### Database Models
[Source: Story 8.1 implementation, adapted in Story 8.3]
The site_structure table actual fields (as implemented):
- id (UUID primary key)
- websiteId (foreign key to websites)
- contentItemId (foreign key to content_items)
- parentId (self-referential foreign key)
- slug (unique per parent)
- fullPath (indexed for O(1) lookups)
- pathDepth (NOT 'depth' - for level queries)
- position (ordering among siblings)
- weight (currently just set to 0)

**IMPORTANT:** The original architecture mentioned `materializedPath` for storing ancestor IDs, but this was NOT implemented. The system uses `fullPath` for all path operations and parent chain traversal instead.

#### Circular Reference Prevention
[Source: docs/epic8-brownfield-architecture.md#move-operations]
Before moving a node, check if the target parent is a descendant of the node being moved:
```typescript
async wouldCreateCycle(nodeId: string, newParentId: string): Promise<boolean> {
  // Get all descendants of nodeId
  // Check if newParentId is in that list
  // Return true if cycle would be created
}
```

### GitFlow Workflow
Branch Name: `feature/8-4-site-structure-service`
Base Branch: main
PR Target: main

Git Commands:
1. Setup: `git checkout main && git pull origin main`
2. Create: `git checkout -b feature/8-4-site-structure-service`
3. Commit: Use conventional commits (feat:, fix:, docs:, etc.)
4. Push: `git push -u origin feature/8-4-site-structure-service`
5. PR: Create PR to main branch with title "Epic 8 Story 8.4: Site Structure Service Layer"

### Testing Standards
[Source: Project conventions]
- Test files location: `__tests__` folder in same directory as source
- Testing framework: Jest with TypeScript
- Coverage requirement: 85%+ for services
- Use test database for integration tests
- Mock Prisma for unit tests using jest.mock()
- Performance tests should validate < 1 second for 100 nodes

### Implementation Example
[Source: docs/epic8-brownfield-architecture.md#site-structure-service]
```typescript
export class SiteStructureService implements ISiteStructureService {
  constructor(
    private readonly repository: ISiteStructureRepository,
    private readonly pathManager: IPathManager,
    private readonly validator: IStructureValidator,
    private readonly eventBus: IEventBus
  ) {}

  async move(nodeId: string, newParentId: string): Promise<SiteStructure> {
    // Prevent circular references
    if (await this.validator.wouldCreateCycle(nodeId, newParentId)) {
      throw new CircularReferenceError();
    }
    
    // Update in transaction
    return await this.repository.transaction(async (trx) => {
      // Update parent and paths
      // Cascade to children
      return updated;
    });
  }
}
```

### Tree Operation Complexity
- getTree: O(n) where n is number of nodes
- getAncestors: O(depth) using parent chain traversal
- getDescendants: O(subtree size)
- move: O(descendants) for path updates
- resolveUrl: O(1) with indexed fullPath

### Error Handling
- Use HTTP 409 for circular reference errors
- Use HTTP 404 for non-existent nodes
- Use HTTP 400 for validation errors
- Always include detailed error messages
- Log errors with context for debugging

### Security Note
Authorization checks for who can modify tree structures are expected to be handled at the API layer (not in this service layer). The service assumes the caller has already been authorized. If authorization logic is needed at the service level, it should be added in a future story.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-22 | 1.0 | Initial story creation for Site Structure Service Layer | Bob (Scrum Master) |
| 2025-08-22 | 1.1 | Updated to reflect actual database schema (pathDepth not depth, no materializedPath) per PO validation | Bob (Scrum Master) |

## Dev Agent Record
### Agent Model Used
<!-- To be filled by Dev Agent -->

### Debug Log References
<!-- To be filled by Dev Agent -->

### Completion Notes List
<!-- To be filled by Dev Agent -->

### File List
<!-- To be filled by Dev Agent -->

## QA Results

### Review Date: 2025-08-22

### Reviewed By: Quinn (Senior Developer QA)

### Implementation Status

**⚠️ NOT IMPLEMENTED** - Story 8.4 has not been started. No implementation files found.

### Pre-Implementation Architecture Review

Since this story hasn't been implemented yet, I'm providing a senior developer review of the story requirements and architecture guidance to ensure successful implementation.

### Critical Architecture Concerns

1. **Database Schema Mismatch Risk** ⚠️
   - Story correctly identifies that `pathDepth` (not `depth`) should be used
   - No `materializedPath` field exists - implementation must use parent chain traversal
   - Developer must carefully follow the adapted schema from Story 8.3

2. **Performance Requirements Challenge** 
   - Bulk operations < 1 second for 100 nodes is aggressive
   - Tree rendering < 100ms for 500 nodes requires careful optimization
   - Recommend implementing caching strategy early, not just "interface only"

3. **Transaction Boundary Complexity**
   - Move operations with path recalculation will be complex in transactions
   - Risk of lock contention with bulk operations
   - Consider using advisory locks for tree-wide operations

### Recommended Implementation Approach

#### Phase 1: Core Foundation (Priority)
1. Start with repository pattern and basic CRUD
2. Implement tree traversal with proper parent chain walking
3. Add comprehensive error handling from the start

#### Phase 2: Path Management
1. Build path manager with careful attention to the `fullPath` field
2. Implement recursive path updates with transaction safety
3. Add path validation and consistency checks

#### Phase 3: Complex Operations
1. Move operations with circular reference prevention
2. Bulk operations with performance optimization
3. Tree validation and repair utilities

### Missing Acceptance Criteria

The following should be added to ensure complete implementation:

- [ ] Concurrent operation safety (pessimistic locking for moves)
- [ ] Memory efficiency for large tree operations
- [ ] Graceful degradation for tree repair operations
- [ ] Metrics/logging for performance monitoring

### Testing Strategy Recommendations

1. **Unit Tests Must Include:**
   - Circular reference detection edge cases
   - Path recalculation with special characters in slugs
   - Transaction rollback scenarios
   - Concurrent move operation conflicts

2. **Integration Tests Must Include:**
   - Stress testing with 1000+ nodes (not just 100)
   - Deep nesting scenarios (10+ levels)
   - Orphaned node recovery
   - Database connection failure handling

### Security Considerations

- Input validation for all tree operations (SQL injection prevention)
- Rate limiting considerations for bulk operations
- Audit logging for tree structure changes
- Consider adding soft-delete capability for recovery

### Implementation Gotchas to Avoid

1. **Don't assume ordered sibling positions** - gaps will occur, handle them
2. **Don't trust client-provided paths** - always recalculate
3. **Don't skip the cycle detection** - it's critical for data integrity
4. **Don't forget index optimization** - fullPath, parentId, websiteId are critical

### Dependency Integration Notes

- PageOrchestrator in `page-orchestrator.ts` has overlapping functionality
- Ensure clear separation of concerns between orchestrator and service
- Reuse existing error classes from `errors.ts`
- Leverage existing slug utilities from `slug-manager.ts`

### Performance Optimization Strategies

1. **Use raw SQL for bulk operations** - Prisma's ORM overhead will be too high
2. **Implement query result caching** - especially for getTree operations
3. **Consider materialized views** for frequently accessed tree structures
4. **Use database-level recursive CTEs** for ancestor/descendant queries

### Code Quality Requirements

When implementing, ensure:
- Proper TypeScript strict mode compliance
- Comprehensive JSDoc documentation
- Clear separation between public API and internal helpers
- Consistent error handling patterns
- Avoid premature optimization - measure first

### Final Status

**📋 Ready for Implementation** - Story is well-defined but requires careful attention to:
1. Database schema adaptations from Story 8.3
2. Performance requirements that may need adjustment
3. Complex transaction management for tree operations
4. Clear separation from PageOrchestrator responsibilities

### Developer Guidance

Start with the simplest operations first (getTree, getAncestors) and build up to complex operations (move, bulk operations). Test thoroughly at each step. The path management and circular reference prevention are the most critical pieces to get right.