# Story 4.6b: Website Storage Service API Implementation

## Status
Draft

## Story
**As a** developer,  
**I want** to implement API-based Website Storage Service,  
**so that** large website data (content, assets, AI context) can be stored on the server.

## Acceptance Criteria
1. Create WebsiteData model for large data storage
2. Implement chunked upload/download endpoints for large data
3. Update WebsiteStorageService to use API exclusively
4. Create import/export functionality for website backups

## Tasks / Subtasks
- [ ] Git Setup (REQUIRED FIRST TASK)
  - [ ] Checkout and update develop: `git checkout develop && git pull origin develop`
  - [ ] Create feature branch: `git checkout -b feature/4-6b-website-storage-service`
- [ ] Create WebsiteData Model (AC: 1)
  - [ ] Add to `prisma/schema.prisma`:
    ```prisma
    model WebsiteData {
      id        String   @id @default(cuid())
      websiteId String   @unique
      content   Json?    // Large content data
      assets    Json?    // Asset references
      aiContext Json?    // AI conversation history
      version   Int      @default(1)
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt
      
      website Website @relation(fields: [websiteId], references: [id], onDelete: Cascade)
    }
    ```
  - [ ] Add relation to Website model: `websiteData WebsiteData?`
  - [ ] Run migration: `npm run db:migrate -- --name add-website-data`
- [ ] Implement Chunked Transfer System (AC: 2)
  - [ ] Create `/lib/api/chunked-transfer.ts`:
    - Chunk large data into 1MB pieces
    - Track upload sessions
    - Reassemble chunks on server
    - Progress tracking mechanism
  - [ ] Create `/app/api/websites/[id]/upload/route.ts`:
    - POST: Accept chunked uploads
    - Track session state
    - Validate chunk order
  - [ ] Create `/app/api/websites/[id]/download/route.ts`:
    - GET: Stream large data in chunks
    - Support range requests
- [ ] Create Website Data API Routes (AC: 2)
  - [ ] Create `/app/api/websites/[id]/data/route.ts`:
    - GET: Retrieve website data (with optional field selection)
    - PUT: Update website data (support partial updates)
    - Handle large JSON payloads
  - [ ] Add compression for large responses
  - [ ] Implement versioning for conflict resolution
- [ ] Update WebsiteStorageService (AC: 3)
  - [ ] Modify `/lib/storage/website-storage.service.ts`:
    - Create `ApiStorageAdapter` class
    - Replace ALL IndexedDB calls with API calls
    - Remove IndexedDB dependencies completely
  - [ ] Update methods:
    - `saveWebsiteData()` - Direct API call
    - `getWebsiteData()` - Direct API call
    - Remove all offline/sync related methods
- [ ] Implement Import/Export (AC: 4)
  - [ ] Create `/app/api/websites/[id]/export/route.ts`:
    - GET: Export website as downloadable JSON file
    - Include all data: metadata, content, assets, AI context
    - Add version and timestamp
  - [ ] Create `/app/api/websites/import/route.ts`:
    - POST: Import website from uploaded JSON
    - Validate import structure
    - Handle duplicate detection
    - Support version compatibility
- [ ] Testing and Validation (AC: 2, 3, 4)
  - [ ] Create chunked transfer tests:
    - Test upload of 10MB+ data
    - Test interrupted uploads
    - Test download streaming
  - [ ] API integration tests:
    - Test CRUD operations
    - Test error handling
    - Test large payload handling
  - [ ] Manual testing checklist:
    - Create website via API
    - Update website data
    - Export large website
    - Import large website
    - Test with slow connection
  - [ ] Performance testing:
    - Measure chunked transfer speed
    - Test with concurrent uploads
    - Verify memory usage stays reasonable
- [ ] Documentation Updates
  - [ ] Document chunked transfer protocol
  - [ ] Document API endpoints and usage
  - [ ] Add troubleshooting guide
  - [ ] Update architecture docs
- [ ] Submit PR (REQUIRED FINAL TASK)
  - [ ] Push branch: `git push -u origin feature/4-6b-website-storage-service`
  - [ ] Create PR from feature branch → develop branch
  - [ ] PR Title: "Epic 4 Story 6b: Website Storage Service API Implementation"
  - [ ] Link PR to story in description

## Dev Notes

### GitFlow Workflow
Branch Name: feature/4-6b-website-storage-service
Base Branch: develop (NOT main)  
PR Target: develop (NOT main)

Git Commands:
1. Setup: `git checkout develop && git pull origin develop`
2. Create: `git checkout -b feature/4-6b-website-storage-service`
3. Commit: Use conventional commits (feat:, fix:, docs:, etc.)
4. Push: `git push -u origin feature/4-6b-website-storage-service`
5. PR: Create PR to develop branch with title "Epic 4 Story 6b: Website Storage Service API Implementation"

### Development Approach
Pure API implementation for local development:
- Direct API calls for all operations
- No offline support needed (local dev only)
- No migration needed (no production data)
- Focus on chunked transfer for large data
- Simple and maintainable

### Database Configuration
[Source: Actual project setup]

**Prisma is already configured:**
- Database: SQLite for development (`prisma/dev.db`)
- Schema location: `prisma/schema.prisma`
- Generated client: `lib/generated/prisma`
- Migrations: `npm run db:migrate`
- Database commands available:
  - `npm run db:generate` - Generate Prisma client
  - `npm run db:migrate` - Run migrations
  - `npm run db:seed` - Seed database
  - `npm run db:studio` - Open Prisma Studio

**Current Schema Structure:**
- Website model exists with: id, name, description, category, metadata
- ContentType and ContentItem models already defined
- Using String fields for JSON data (SQLite compatibility)

### Chunked Transfer Implementation
[Source: Next.js API route capabilities]

```typescript
// Chunked Upload Session Management
interface ChunkSession {
  sessionId: string;
  websiteId: string;
  totalChunks: number;
  receivedChunks: Set<number>;
  chunks: Map<number, Buffer>;
  startedAt: Date;
  lastActivity: Date;
}

// Store sessions in memory (for development)
const uploadSessions = new Map<string, ChunkSession>();

// Chunk metadata for transfer
interface ChunkMetadata {
  sessionId: string;
  totalChunks: number;
  chunkIndex: number;
  chunkSize: number;
  checksum?: string; // Optional for development
}

// 1MB chunk size (configurable)
const CHUNK_SIZE = 1024 * 1024; // 1MB
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
```

### API Implementation Patterns
[Source: Next.js App Router documentation]

**Standard API Route Structure:**
```typescript
// app/api/websites/[id]/data/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/generated/prisma';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const websiteData = await prisma.websiteData.findUnique({
      where: { websiteId: params.id }
    });
    
    if (!websiteData) {
      return NextResponse.json(
        { error: 'Website data not found' },
        { status: 404 }
      );
    }
    
    return NextResponse.json({ data: websiteData });
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**Error Handling Pattern:**
```typescript
// Standard error response format
interface ApiError {
  error: string;
  details?: any;
  code?: string;
}

// Standard success response format
interface ApiResponse<T> {
  data: T;
  meta?: {
    page?: number;
    total?: number;
  };
}
```

### WebsiteStorageService Update Approach
[Source: Existing file at lib/storage/website-storage.service.ts]

The existing service uses IndexedDB. Update strategy:
1. Create new `ApiStorageAdapter` class in same file
2. Replace IndexedDB operations with fetch calls
3. Keep same public interface for backward compatibility
4. Use environment check to switch between adapters

```typescript
// Example adapter pattern
class ApiStorageAdapter {
  async saveWebsiteData(websiteId: string, data: any) {
    const response = await fetch(`/api/websites/${websiteId}/data`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!response.ok) throw new Error('Failed to save');
    return response.json();
  }
  
  async getWebsiteData(websiteId: string) {
    const response = await fetch(`/api/websites/${websiteId}/data`);
    if (!response.ok) throw new Error('Failed to load');
    return response.json();
  }
}
```

### Testing Configuration
[Source: package.json and project setup]

**Available Testing Tools:**
- Jest for unit tests (configured)
- Test commands:
  - `npm test` - Run tests
  - `npm run test:watch` - Watch mode
  - `npm run test:coverage` - Coverage report
- Test database: `test.db` (separate from dev.db)
- Test setup: `npm run test:db:setup`

**Testing Approach:**
```typescript
// Example test structure
describe('WebsiteData API', () => {
  beforeEach(async () => {
    // Reset test database
    await prisma.websiteData.deleteMany();
  });
  
  test('should handle large data upload', async () => {
    // Test implementation
  });
});
```

### Dependencies
This story depends on:
- Story 4.6a: Website core migration (basic Website model exists in schema)
- Story 4.2: Database setup (Prisma is configured and working)

### Important Implementation Notes

1. **Performance Critical**: Large data handling must not block UI
2. **Memory Management**: Stream large data, don't load all in memory
3. **API First**: Direct API calls for all operations
4. **Data Integrity**: Optional checksums for development (can add later for production)
5. **Progress Feedback**: Return progress in API responses

### Actual Project Structure
```
Current structure:
lib/
├── storage/
│   ├── website-storage.service.ts  (exists - modify to add API adapter)
│   ├── types.ts                    (exists - data types)
│   └── __tests__/                  (exists - test directory)
├── generated/
│   └── prisma/                     (Prisma client location)
│   
app/
└── api/
    └── websites/                   (create this structure)
        ├── [id]/
        │   ├── data/
        │   │   └── route.ts        (create)
        │   ├── upload/
        │   │   └── route.ts        (create)
        │   ├── download/
        │   │   └── route.ts        (create)
        │   └── export/
        │       └── route.ts        (create)
        └── import/
            └── route.ts            (create)

prisma/
├── schema.prisma                   (exists - add WebsiteData model)
├── dev.db                          (exists - development database)
└── migrations/                     (exists - migration history)
```

### Validation Schema with Zod
[Source: Zod is installed in package.json]

```typescript
import { z } from 'zod';

// WebsiteData validation schema
const WebsiteDataSchema = z.object({
  content: z.any().optional(),
  assets: z.any().optional(),
  aiContext: z.any().optional(),
});

// Chunk upload validation
const ChunkUploadSchema = z.object({
  sessionId: z.string(),
  chunkIndex: z.number().min(0),
  totalChunks: z.number().min(1),
  data: z.string(), // Base64 encoded chunk
});
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-12 | 1.0 | Created as part of story split | Bob (Scrum Master) |
| 2025-08-12 | 2.0 | Simplified: removed migration and offline sync - pure API implementation | Bob (Scrum Master) |
| 2025-08-12 | 3.0 | Fixed all PO validation issues - added concrete implementation patterns, verified dependencies, included actual project structure | Bob (Scrum Master) |

## Dev Agent Record
*To be populated during implementation*

### Agent Model Used
*To be populated*

### Debug Log References
*To be populated*

### Completion Notes List
*To be populated*

### File List
*To be populated*

## QA Results
*To be populated during QA review*