# Story 5.4: Content Item Management Tools

## Status
Approved

## Story
**As a** content creator,  
**I want** to create and manage content items via AI commands,  
**so that** I can rapidly populate my website with content.

## Acceptance Criteria
1. `list-content-items` retrieves items with filtering options
2. `create-content-item` adds new content with validation
3. `update-content-item` modifies existing content safely
4. Bulk operations limited to 20 items per request
5. All operations respect content type field definitions

## Tasks / Subtasks
- [ ] Git Setup (REQUIRED FIRST TASK)
  - [ ] Continue with existing branch: `git checkout feature/5-2-website-management-tools`
  - [ ] Pull latest changes: `git pull origin feature/5-2-website-management-tools`
- [ ] Create Content Item Tools Directory Structure (AC: 1, 2, 3)
  - [ ] Create `/lib/ai-tools/tools/content-items/` directory
  - [ ] Create `index.ts` for barrel exports
- [ ] Implement list-content-items Tool (AC: 1, 4)
  - [ ] Create `/lib/ai-tools/tools/content-items/list-content-items.ts`
  - [ ] Define tool using Vercel AI SDK pattern with Zod schema
  - [ ] Add filtering parameters: websiteId, contentTypeId, status, limit (max 20)
  - [ ] Implement execute function using existing content item APIs
  - [ ] Include parsed field values in response
  - [ ] Add performance monitoring for <2s requirement
  - [ ] Write unit tests in `__tests__/list-content-items.test.ts`
- [ ] Implement create-content-item Tool (AC: 2, 5)
  - [ ] Create `/lib/ai-tools/tools/content-items/create-content-item.ts`
  - [ ] Define tool with comprehensive Zod schema for content creation
  - [ ] Validate against content type field definitions
  - [ ] Use business rules engine from Story 5.2 for field validation
  - [ ] Implement execute function with database operations
  - [ ] Wrap in Prisma transaction for atomic creation
  - [ ] Handle field type conversions (JSON strings)
  - [ ] Write unit tests including validation scenarios
- [ ] Implement update-content-item Tool (AC: 3, 5)
  - [ ] Create `/lib/ai-tools/tools/content-items/update-content-item.ts`
  - [ ] Define tool with Zod schema for safe updates
  - [ ] Implement execute function for content updates
  - [ ] Ensure field modifications respect content type schema
  - [ ] Apply field-level validation based on content type
  - [ ] Wrap in Prisma transaction for atomic updates
  - [ ] Write unit tests including safety checks
- [ ] Implement Bulk Operation Support (AC: 4)
  - [ ] Add bulk operation limits (max 20 items) to list tool
  - [ ] Implement bulk validation in create/update tools
  - [ ] Add safeguards against excessive operations
  - [ ] Test bulk operation performance
- [ ] Update Tool Registry (AC: 1, 2, 3)
  - [ ] Export all content item tools in `/lib/ai-tools/tools/content-items/index.ts`
  - [ ] Update `/lib/ai-tools/tools/index.ts` to include content item tools
  - [ ] Ensure tools are available in allTools export for chat route
- [ ] Testing and Validation
  - [ ] Write comprehensive unit tests for each tool
  - [ ] Test field validation against content type definitions
  - [ ] Test bulk operation limits and performance
  - [ ] Verify integration with existing content item APIs
  - [ ] Test transaction rollback on failures
  - [ ] Test performance for <2s requirement
- [ ] Integration Verification (IV)
  - [ ] IV1: Verify tools use existing ContentItemService methods
  - [ ] IV2: Verify created items appear correctly in existing content management UI
  - [ ] IV3: Verify no data corruption with concurrent manual and AI operations
- [ ] Submit PR (REQUIRED FINAL TASK)
  - [ ] Push branch: `git push origin feature/5-2-website-management-tools`
  - [ ] Update existing PR with Story 5.4 changes
  - [ ] PR Title remains: "Epic 5: AI-Powered Content Management Tools"
  - [ ] Update PR description to include Story 5.4 completion

## Dev Notes

### GitFlow Workflow
Branch Name: feature/5-2-website-management-tools (CONTINUING EXISTING BRANCH)
Base Branch: main (NOTE: Repository uses 'main' not 'develop')
PR Target: main

Git Commands:
1. Setup: `git checkout feature/5-2-website-management-tools`
2. Pull: `git pull origin feature/5-2-website-management-tools`
3. Commit: Use conventional commits (feat:, fix:, docs:, etc.)
4. Push: `git push origin feature/5-2-website-management-tools`
5. PR: Update existing PR with Story 5.4 implementation

### Technical Architecture Context

**Previous Story Insights** [From Stories 5.2 and 5.3]:
- Tool infrastructure successfully implemented with Vercel AI SDK patterns
- Business rules engine created at `/lib/ai-tools/business-rules.ts` with category-specific validation
- Repository uses 'main' branch instead of 'develop'
- Tool executor handles Zod validation and Prisma transactions
- `/lib/ai-tools/tools/index.ts` already exists for tool exports
- Performance monitoring pattern established in website and content type tools
- Transaction support pattern established for atomic operations
- Content type tools successfully implemented with field inference
- ContentTypeService integration patterns established

**Tool Implementation Pattern** [Source: Story 5.2/5.3 implementation]:
```typescript
import { tool } from 'ai';
import { z } from 'zod';

export const toolName = tool({
  description: 'Tool description',
  parameters: z.object({
    param: z.string().describe('Parameter description')
  }),
  execute: async ({ param }) => {
    // Implementation with service calls
  }
});
```

**Content Item API Integration** [Source: architecture/epic-5-architecture.md]:
- Use existing content item APIs at `/lib/api/content-items.ts`
- Available functions (inferred from file structure):
  - Create, read, update, delete operations for content items
  - Validation utilities at `/lib/api/validation/content-item.ts`
- Content items store at `/lib/stores/content-items-store.ts` for state management

**Content Item Data Structure** [Source: Prisma schema inferred from architecture]:
- ContentItem model includes: id, websiteId, contentTypeId, fields (JSON string), status, metadata
- Fields are stored as JSON strings matching content type field definitions
- Each content item must conform to its content type's field schema

**Business Rules Integration** [From Story 5.2]:
- Business rules engine at `/lib/ai-tools/business-rules.ts`
- Methods available:
  - `validateForCategory(data, category)` - Apply category rules
  - `validateFieldValue(field, value, contentType)` - Validate individual field
  - `applyDefaultValues(fields, contentType)` - Set default values

**Field Validation Requirements** [Source: epic-5-architecture.md]:
- All content item fields must match their content type definition
- Required fields must be present
- Field types must be validated (text, number, date, boolean, etc.)
- Field constraints must be enforced (min/max length, patterns, etc.)
- Category-specific rules must be applied

**Bulk Operation Constraints** [Source: epic-5-prd.md]:
- Maximum 20 items per bulk operation request
- All items in bulk operation must belong to same website
- Atomic transactions for bulk operations (all succeed or all fail)
- Performance target remains <2s even for bulk operations

**File Structure Requirements** [Source: epic-5-architecture.md]:
```
/lib/ai-tools/tools/content-items/
├── list-content-items.ts
├── create-content-item.ts
├── update-content-item.ts
├── index.ts (barrel export)
└── __tests__/
    ├── list-content-items.test.ts
    ├── create-content-item.test.ts
    └── update-content-item.test.ts
```

**Transaction Pattern** [From Story 5.2/5.3]:
```typescript
import { getClient } from '@/lib/db/client';

const prisma = getClient();
const result = await prisma.$transaction(async (tx) => {
  // Operations using tx instead of prisma
  return await tx.contentItem.create({ ... });
});
```

**Performance Monitoring Pattern** [From Story 5.2/5.3]:
```typescript
const startTime = Date.now();
// ... tool execution ...
const executionTime = Date.now() - startTime;
if (executionTime > 2000) {
  console.warn(`Tool execution exceeded 2s: ${executionTime}ms`);
}
```

**Content Type Field Integration** [From Story 5.3]:
- Content types have parsed fields with specific types
- Field types include: text, number, date, boolean, select, multiselect, json
- Each field has validation rules (required, min, max, pattern, etc.)
- Content items must validate against these field definitions

### Testing Standards

**Test Framework**: Jest with TypeScript
**Test Location**: Create `__tests__` folder within `/lib/ai-tools/tools/content-items/`
**Test Pattern**: Follow existing pattern from website and content type tools tests
**Coverage Target**: 90% for tool functions

**Test Requirements**:
- Mock content item API calls
- Test parameter validation with invalid inputs
- Test successful execution paths
- Test error handling and rollback
- Test field validation against content type
- Test bulk operation limits
- Test performance monitoring

**Example Test Structure** [From Story 5.2/5.3]:
```typescript
import { toolName } from '../tool-name';

jest.mock('@/lib/api/content-items');

describe('Tool Name', () => {
  it('should validate parameters', async () => {
    // Test Zod validation
  });
  
  it('should execute successfully', async () => {
    // Test happy path
  });
  
  it('should handle errors gracefully', async () => {
    // Test error scenarios
  });
  
  it('should enforce bulk limits', async () => {
    // Test max 20 items constraint
  });
});
```

### Project Structure Notes
- Content item tools follow same pattern as website and content type tools
- All paths align with architecture document specifications
- Integration with existing content item APIs required
- No new API endpoints - tools are server-side functions only

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-14 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated during implementation_

### Completion Notes List
_To be populated during implementation_

### File List
_To be populated during implementation_

## QA Results
_To be populated by QA agent_