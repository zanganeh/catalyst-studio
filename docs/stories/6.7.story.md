# Story 6.7: Build Sync State Management

## Status
Approved

## Story
**As a** system,  
**I want to** maintain sync state between sessions,  
**So that** I know what has been synced previously

## Acceptance Criteria
1. Persist last sync timestamps per content type
2. Track sync checksums for comparison
3. Handle interrupted sync recovery
4. Support incremental synchronization
5. All sync state operations are properly unit tested

## Tasks / Subtasks
- [ ] Git Setup (REQUIRED FIRST TASK)
  - [ ] Checkout and update main: `git checkout main && git pull origin main`
  - [ ] Create feature branch: `git checkout -b feature/epic6-sync-state`
- [ ] Update Database Schema for Sync State (AC: 1, 2)
  - [ ] Update existing `SyncState` model in `prisma/schema.prisma` (created in Story 6.5)
  - [ ] Add new fields: lastSyncAt, conflictStatus, syncProgress, createdAt, updatedAt
  - [ ] Add indexes for syncStatus and lastSyncAt
  - [ ] Create Prisma migration: `npx prisma migrate dev --name update_sync_state_table`
  - [ ] Verify migration creates table correctly
  - [ ] Add unit tests for Prisma operations on SyncState
- [ ] Build SyncStateManager Service (AC: 1, 2)
  - [ ] Create `/lib/sync/state/SyncStateManager.ts` in TypeScript
  - [ ] Implement `updateSyncState()` method to track sync timestamps and hashes
  - [ ] Implement `getSyncState()` method to retrieve current state
  - [ ] Implement `compareSyncStates()` method to detect changes
  - [ ] Add comprehensive unit tests for all methods
- [ ] Implement Incremental Sync Logic (AC: 4)
  - [ ] Create `getContentTypesSince()` method to fetch changes since last sync
  - [ ] Implement `calculateDelta()` method to determine what needs syncing
  - [ ] Add `markAsSynced()` method to update state after successful sync
  - [ ] Test incremental sync with various scenarios
- [ ] Create Interrupted Sync Recovery (AC: 3)
  - [ ] Implement `detectInterruptedSync()` method using sync_status field
  - [ ] Create `resumeSync()` method to continue from last checkpoint
  - [ ] Add `rollbackPartialSync()` method for failed syncs
  - [ ] Store sync progress checkpoints in database
  - [ ] Test recovery scenarios with simulated failures
- [ ] Build Sync State Persistence Layer (AC: 1, 2)
  - [ ] Create database access methods using Prisma client
  - [ ] Implement atomic updates for sync state changes
  - [ ] Add transaction support for multi-type syncs
  - [ ] Ensure proper error handling and rollback
  - [ ] Test database operations thoroughly
- [ ] Create Sync State API Endpoints (AC: 1, 2, 4)
  - [ ] Create `/app/api/v1/sync/state/route.ts`
  - [ ] Implement GET endpoint to retrieve sync state
  - [ ] Implement POST endpoint to update sync state
  - [ ] Add endpoint for checking sync status
  - [ ] Test API endpoints with various payloads
- [ ] Integrate with Existing Sync Components (AC: 1, 2, 3, 4)
  - [ ] Update deployment-service.ts to use SyncStateManager
  - [ ] Integrate with ConflictDetector from Story 6.6
  - [ ] Connect to ChangeDetector from Story 6.5
  - [ ] Ensure state is updated after each sync operation
  - [ ] Test integration with existing sync pipeline
- [ ] Add State Management UI Integration (AC: 1, 4)
  - [ ] Create hook to fetch sync state from API
  - [ ] Display last sync timestamps in deployment UI
  - [ ] Show sync status indicators for each content type
  - [ ] Add refresh button to update state display
  - [ ] Test UI updates reflect database state correctly
- [ ] Submit PR (REQUIRED FINAL TASK)
  - [ ] Push branch: `git push -u origin feature/epic6-sync-state`
  - [ ] Create PR from feature branch → main branch
  - [ ] PR Title: "feat(sync): implement persistent sync state management"
  - [ ] Link PR to story in description

## Dev Notes

### GitFlow Workflow
Branch Name: feature/epic6-sync-state
Base Branch: main
PR Target: main

Git Commands:
1. Setup: `git checkout main && git pull origin main`
2. Create: `git checkout -b feature/epic6-sync-state`
3. Commit: Use conventional commits - `git commit -m "feat(sync): implement persistent sync state management"`
4. Push: `git push -u origin feature/epic6-sync-state`
5. PR: Create PR to main branch with title "feat(sync): implement persistent sync state management"

### Previous Story Insights
[Source: Story 6.6 Dev Agent Record]
- ConflictDetector successfully implemented with three-way diff capability
- Database schema pattern established with ConflictLog table
- Prisma migrations working correctly for new tables
- TypeScript implementations in `/lib/sync/conflict/` directory
- API endpoints pattern established in `/app/api/v1/sync/` directory
- Integration with deployment-service.ts completed
- Testing pattern: Jest tests adjacent to source files

[Source: Story 6.5 Dev Agent Record]
- ChangeDetector in `/lib/sync/detection/ChangeDetector.ts`
- SyncState table already created with basic structure
- Performance: Fast operations (<100ms typical)

### Technical Architecture Context
[Source: Epic 6 Architecture & PRD State Management Section]

**Sync State Management Architecture**:
- Purpose: Maintain persistent sync state between sessions
- Integration: Core component for incremental synchronization
- Location: `/lib/sync/state/` directory for TypeScript implementation
- Recovery: Support for interrupted sync continuation

**File Structure** (Building on existing):
```
/lib/sync/                    # Production TypeScript code
├── detection/
│   └── ChangeDetector.ts     # EXISTING - From Story 6.5
├── conflict/
│   ├── ConflictDetector.ts   # EXISTING - From Story 6.6
│   ├── ThreeWayDiff.ts       # EXISTING - From Story 6.6
│   └── ResolutionStrategy.ts # EXISTING - From Story 6.6
├── state/
│   └── SyncStateManager.ts   # NEW - This story
├── versioning/
│   ├── ContentTypeHasher.ts  # EXISTING - From Story 6.2
│   └── VersionHistory.ts     # EXISTING - From Story 6.3
└── tracking/
    └── SyncHistoryManager.ts # EXISTING - From Story 6.4
```

### Database Schema
[Source: Epic 6 PRD - Story 6.7 State Management Schema]

**SyncState Table Update** (extending existing table from Story 6.5):

**Current Schema from Story 6.5:**
```prisma
model SyncState {
  typeKey         String   @id @map("type_key")
  localHash       String   @map("local_hash")
  remoteHash      String?  @map("remote_hash")
  lastSyncedHash  String?  @map("last_synced_hash")
  syncStatus      String   @map("sync_status") // new/modified/conflict/in_sync
  
  @@map("sync_state")
}
```

**Updated Schema for Story 6.7:**
```prisma
model SyncState {
  typeKey        String   @id @map("type_key")
  localHash      String?  @map("local_hash")        // Make nullable
  remoteHash     String?  @map("remote_hash")       // Already nullable
  lastSyncedHash String?  @map("last_synced_hash")  // Already nullable
  lastSyncAt     DateTime? @map("last_sync_at")     // NEW FIELD
  syncStatus     String?  @map("sync_status")       // Make nullable, add: syncing/failed
  conflictStatus String?  @map("conflict_status")   // NEW FIELD: none/detected/resolved
  syncProgress   Json?    @map("sync_progress")     // NEW FIELD: For interrupted sync recovery
  createdAt      DateTime @default(now()) @map("created_at") // NEW FIELD
  updatedAt      DateTime @updatedAt @map("updated_at")      // NEW FIELD
  
  @@map("sync_state")
  @@index([syncStatus])    // NEW INDEX
  @@index([lastSyncAt])    // NEW INDEX
}
```

IMPORTANT: This story UPDATES the existing SyncState table created in Story 6.5, adding new fields and indexes for enhanced state management.

### Implementation Details
[Source: Epic 6 Architecture - State Management Component]

**SyncStateManager Implementation**:
```typescript
// /lib/sync/state/SyncStateManager.ts
export class SyncStateManager {
  constructor(private prisma: PrismaClient) {}
  
  async updateSyncState(typeKey: string, state: Partial<SyncState>): Promise<void> {
    await this.prisma.syncState.upsert({
      where: { typeKey },
      update: {
        ...state,
        updatedAt: new Date()
      },
      create: {
        typeKey,
        ...state
      }
    });
  }
  
  async getSyncState(typeKey: string): Promise<SyncState | null> {
    return await this.prisma.syncState.findUnique({
      where: { typeKey }
    });
  }
  
  async getContentTypesSince(timestamp: Date): Promise<string[]> {
    const states = await this.prisma.syncState.findMany({
      where: {
        updatedAt: { gt: timestamp }
      },
      select: { typeKey: true }
    });
    return states.map(s => s.typeKey);
  }
  
  async markAsSynced(typeKey: string, localHash: string, remoteHash: string): Promise<void> {
    await this.updateSyncState(typeKey, {
      localHash,
      remoteHash,
      lastSyncedHash: localHash,
      lastSyncAt: new Date(),
      syncStatus: 'in_sync',
      conflictStatus: 'none'
    });
  }
  
  async detectInterruptedSync(): Promise<string[]> {
    const interrupted = await this.prisma.syncState.findMany({
      where: {
        syncStatus: 'syncing'
      },
      select: { typeKey: true }
    });
    return interrupted.map(s => s.typeKey);
  }
  
  async resumeSync(typeKey: string): Promise<any> {
    const state = await this.getSyncState(typeKey);
    if (!state?.syncProgress) {
      throw new Error('No sync progress found to resume');
    }
    return state.syncProgress;
  }
  
  async rollbackPartialSync(typeKey: string): Promise<void> {
    await this.updateSyncState(typeKey, {
      syncStatus: 'failed',
      syncProgress: null
    });
  }
}
```

**Incremental Sync Logic**:
```typescript
// Calculate what needs syncing
async calculateDelta(typeKey: string): Promise<SyncDelta> {
  const state = await this.getSyncState(typeKey);
  const currentLocal = await this.hasher.calculateHash(typeKey);
  const currentRemote = await this.remoteClient.getHash(typeKey);
  
  if (!state) {
    return { action: 'INITIAL_SYNC', localHash: currentLocal };
  }
  
  if (state.localHash !== currentLocal && state.remoteHash !== currentRemote) {
    return { action: 'CONFLICT', localHash: currentLocal, remoteHash: currentRemote };
  }
  
  if (state.localHash !== currentLocal) {
    return { action: 'PUSH', localHash: currentLocal };
  }
  
  if (state.remoteHash !== currentRemote) {
    return { action: 'PULL', remoteHash: currentRemote };
  }
  
  return { action: 'NO_CHANGE' };
}
```

### API Endpoint Structure
[Source: Next.js 14 App Router pattern from previous stories]

```typescript
// /app/api/v1/sync/state/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { SyncStateManager } from '@/lib/sync/state/SyncStateManager';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const typeKey = searchParams.get('typeKey');
  
  const manager = new SyncStateManager();
  
  if (typeKey) {
    const state = await manager.getSyncState(typeKey);
    return NextResponse.json({ state });
  }
  
  // Get all sync states
  const states = await manager.getAllSyncStates();
  return NextResponse.json({ states });
}

export async function POST(request: NextRequest) {
  const { typeKey, state } = await request.json();
  
  const manager = new SyncStateManager();
  await manager.updateSyncState(typeKey, state);
  
  return NextResponse.json({ success: true });
}
```

### Integration with Existing Components
[Source: Stories 6.5 and 6.6 implementations]

1. **ChangeDetector Integration**: 
   ```typescript
   const changes = await changeDetector.detectChanges();
   for (const typeKey of changes.updated) {
     await syncStateManager.updateSyncState(typeKey, {
       syncStatus: 'modified',
       localHash: changes.hashes[typeKey]
     });
   }
   ```

2. **ConflictDetector Integration**:
   ```typescript
   const state = await syncStateManager.getSyncState(typeKey);
   if (state?.conflictStatus === 'detected') {
     const conflict = await conflictDetector.getConflict(typeKey);
     // Handle conflict before sync
   }
   ```

3. **Deployment Service Integration**:
   ```typescript
   // In deployment-service.ts
   async syncContentType(typeKey: string) {
     await this.syncStateManager.updateSyncState(typeKey, {
       syncStatus: 'syncing',
       syncProgress: { step: 1, total: 3 }
     });
     
     try {
       // Perform sync operations
       await this.syncStateManager.markAsSynced(typeKey, localHash, remoteHash);
     } catch (error) {
       await this.syncStateManager.rollbackPartialSync(typeKey);
       throw error;
     }
   }
   ```

### Error Handling Pattern
[Source: Story 6.5 and 6.6 patterns]
```typescript
try {
  await syncStateManager.updateSyncState(typeKey, { syncStatus: 'syncing' });
  // Perform sync operations
  await syncStateManager.markAsSynced(typeKey, localHash, remoteHash);
} catch (error) {
  console.error(`Sync failed for ${typeKey}:`, error);
  await syncStateManager.updateSyncState(typeKey, {
    syncStatus: 'failed',
    syncProgress: null
  });
  await this.logError(error, 'SYNC_STATE_UPDATE_FAILED', typeKey);
  // Don't throw - allow other types to continue
}
```

### Testing Standards
[Source: Previous stories testing patterns]

**Test Framework**: Jest (already configured)
**Test Location**: Adjacent `__tests__` folders for TypeScript files
**Coverage Target**: Minimum 80% code coverage for state management logic

**Required Test Scenarios**:
```typescript
// /lib/sync/state/__tests__/SyncStateManager.test.ts
describe('SyncStateManager', () => {
  it('should persist sync timestamps', async () => {
    // Setup: Create manager and update state
    // Run: updateSyncState with timestamp
    // Assert: timestamp persisted correctly
  });
  
  it('should track sync checksums', async () => {
    // Setup: Initial state with hashes
    // Run: Update with new hashes
    // Assert: hashes tracked correctly
  });
  
  it('should detect interrupted syncs', async () => {
    // Setup: Set sync status to 'syncing'
    // Run: detectInterruptedSync()
    // Assert: interrupted sync detected
  });
  
  it('should support incremental sync', async () => {
    // Setup: Previous sync state
    // Run: calculateDelta()
    // Assert: correct delta calculated
  });
  
  it('should handle sync recovery', async () => {
    // Setup: Interrupted sync with progress
    // Run: resumeSync()
    // Assert: progress data retrieved
  });
  
  it('should rollback failed syncs', async () => {
    // Setup: Sync in progress
    // Run: rollbackPartialSync()
    // Assert: status set to failed
  });
});
```

### Performance Considerations
[Source: Epic 6 Architecture]
- Use database indexes on syncStatus and lastSyncAt for fast queries
- Batch state updates when syncing multiple types
- Implement connection pooling for database access
- Cache frequently accessed states in memory

### MVP Focus
[Source: Epic 6 PRD - MVP Context]
**Required for MVP**:
- Basic state persistence (timestamps and hashes)
- Simple incremental sync support
- Interrupted sync detection
- Recovery mechanism for failed syncs

**Not Required for MVP**:
- Complex checkpoint strategies
- Parallel sync state management
- State history/audit trail
- Advanced recovery algorithms

### Dependencies
[Source: Current package.json & previous stories]
- **Prisma**: Already installed and configured
- **TypeScript**: Project standard
- **Next.js 14**: For API routes
- No new npm packages required for this story

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-18 | 1.0 | Initial story creation based on Epic 6 PRD and architecture | Scrum Master (Bob) |
| 2025-01-18 | 1.1 | Clarified SyncState table update (not create) based on PO review | Scrum Master (Bob) |

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results