# Story 8.1: Database Schema Implementation

## Story Metadata
- **Epic**: Epic 8 - AI-Powered Site Structure Generation
- **Story ID**: 8.1
- **Story Points**: 5
- **Priority**: P0 (Critical)
- **Dependencies**: None (First story in Epic 8)
- **Risk Level**: Low
- **Estimated Duration**: 1 day

## Story Description

As a **developer**, I need to **implement the database schema for storing hierarchical site structures** so that **we can persist and query page relationships with parent-child hierarchies and URL routing capabilities**.

## Background & Context

Based on the Epic 8 requirements and expert validation from 7 CMS platform architects, we are implementing a hybrid storage pattern (Adjacency List + Materialized Path) for site structures. This approach has been unanimously approved by experts from Optimizely, Strapi, Contentful, WordPress, Drupal, Sanity, and Sitecore as the optimal solution for balancing simplicity and performance.

### Key Design Decisions (Pre-validated)
- **Hybrid Storage Pattern**: Combines `parent_id` (adjacency list) with `full_path` (materialized path)
- **Slug Uniqueness**: Enforced at sibling level via database constraint
- **Path Management**: TEXT type for `full_path` to support enterprise-scale hierarchies
- **Performance Optimization**: Strategic indexes for O(1) URL resolution

## Acceptance Criteria

### ✅ Schema Updated Directly
- [ ] Prisma schema file updated with SiteStructure model
- [ ] All required fields present as specified
- [ ] Proper data types matching existing conventions (cuid, camelCase)
- [ ] Timestamps configured correctly
- [ ] Database reset with new schema: `npx prisma db push --force-reset`

### ✅ Core Table Structure
```sql
-- Following existing naming conventions (camelCase, cuid for ids)
CREATE TABLE "SiteStructure" (
    id TEXT PRIMARY KEY DEFAULT cuid(),
    "websiteId" TEXT NOT NULL REFERENCES "Website"(id) ON DELETE CASCADE,
    "contentItemId" TEXT REFERENCES "ContentItem"(id) ON DELETE SET NULL,
    "parentId" TEXT REFERENCES "SiteStructure"(id) ON DELETE CASCADE,
    slug VARCHAR(255) NOT NULL,
    "fullPath" TEXT NOT NULL,
    "pathDepth" INTEGER NOT NULL DEFAULT 0,
    position INTEGER NOT NULL DEFAULT 0,
    weight INTEGER GENERATED ALWAYS AS (position) STORED,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### ✅ Constraints Implemented
- [ ] `UNIQUE (parent_id, slug)` - Ensures slug uniqueness at sibling level
- [ ] `CHECK (id != parent_id)` - Prevents self-referencing
- [ ] Foreign key constraints with proper cascade rules

### ✅ Performance Indexes Created
- [ ] Index on `fullPath` - For O(1) URL resolution
- [ ] Index on `parentId` - For efficient children queries
- [ ] Index on `websiteId` - For website filtering
- [ ] Index on `pathDepth` - For level-based queries
- [ ] Index on `contentItemId` - For content relationships

### ✅ ContentItem Table Relations
- [ ] Add relation to SiteStructure in ContentItem model
- [ ] SiteStructure can reference ContentItem via contentItemId
- [ ] One-to-many relationship (one content item can be used in multiple site structure nodes)

### ✅ Database Triggers (Optional for MVP)
- [ ] Consider implementing path update trigger (can be deferred to Story 8.5)
- [ ] Document decision on trigger vs application-level path management

## Technical Implementation Details

### 1. Prisma Schema Updates

```prisma
model SiteStructure {
  id            String   @id @default(cuid())
  websiteId     String
  contentItemId String?
  parentId      String?
  slug          String   @db.VarChar(255)
  fullPath      String   @db.Text
  pathDepth     Int      @default(0)
  position      Int      @default(0)
  weight        Int      @default(0) // Computed from position
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  website      Website      @relation(fields: [websiteId], references: [id], onDelete: Cascade)
  contentItem  ContentItem? @relation(fields: [contentItemId], references: [id], onDelete: SetNull)
  parent       SiteStructure?  @relation("SiteStructureHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children     SiteStructure[] @relation("SiteStructureHierarchy")

  @@unique([parentId, slug])
  @@index([fullPath])
  @@index([parentId])
  @@index([websiteId])
  @@index([pathDepth])
  @@index([contentItemId])
}

// Update ContentItem model to add relation
model ContentItem {
  // ... existing fields remain unchanged ...
  
  // Add relation to SiteStructure
  siteStructures SiteStructure[]
  
  // ... rest of model ...
}
```

### 2. Seed Data Implementation

Update `prisma/seed.ts` to include comprehensive site structure test data:

```typescript
// prisma/seed.ts - Add comprehensive site structure
async function seedSiteStructure(websiteId: string) {
  // Create homepage (root)
  const homepage = await prisma.siteStructure.create({
    data: {
      websiteId,
      slug: 'home',
      fullPath: '/',
      pathDepth: 0,
      position: 0
    }
  });

  // Level 1 pages
  const products = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: homepage.id,
      slug: 'products',
      fullPath: '/products',
      pathDepth: 1,
      position: 0
    }
  });

  const about = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: homepage.id,
      slug: 'about',
      fullPath: '/about',
      pathDepth: 1,
      position: 1
    }
  });

  const blog = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: homepage.id,
      slug: 'blog',
      fullPath: '/blog',
      pathDepth: 1,
      position: 2
    }
  });

  // Level 2 pages (under products)
  const electronics = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: products.id,
      slug: 'electronics',
      fullPath: '/products/electronics',
      pathDepth: 2,
      position: 0
    }
  });

  const clothing = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: products.id,
      slug: 'clothing',
      fullPath: '/products/clothing',
      pathDepth: 2,
      position: 1
    }
  });

  // Level 3 pages (under electronics)
  const phones = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: electronics.id,
      slug: 'phones',
      fullPath: '/products/electronics/phones',
      pathDepth: 3,
      position: 0
    }
  });

  const laptops = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: electronics.id,
      slug: 'laptops',
      fullPath: '/products/electronics/laptops',
      pathDepth: 3,
      position: 1
    }
  });

  // Level 2 pages (under about)
  const team = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: about.id,
      slug: 'team',
      fullPath: '/about/team',
      pathDepth: 2,
      position: 0
    }
  });

  const mission = await prisma.siteStructure.create({
    data: {
      websiteId,
      parentId: about.id,
      slug: 'mission',
      fullPath: '/about/mission',
      pathDepth: 2,
      position: 1
    }
  });

  console.log('✅ Site structure seeded with 10 pages across 4 levels');
  return { homepage, products, about, blog };
}
```

## Testing Requirements

### Unit Tests
```typescript
describe('SiteStructure Schema', () => {
  test('creates site structure with all required fields');
  test('enforces unique slug constraint at sibling level');
  test('prevents self-referencing parent');
  test('cascades deletion properly');
  test('generates weight from position');
});
```

### Integration Tests
```typescript
describe('Database Performance', () => {
  test('URL resolution query performs in < 10ms');
  test('children query uses index efficiently');
  test('handles deep hierarchies (10+ levels)');
});
```

## Implementation Checklist

### Pre-Implementation
- [ ] Review existing Prisma schema
- [ ] Ensure local database is running
- [ ] Verify Prisma CLI is installed and configured

### Implementation Steps
1. [ ] Update Prisma schema file with SiteStructure model
2. [ ] Remove category field from ContentItem (already exists as enum in ContentType)
3. [ ] Add relation between SiteStructure and ContentItem
4. [ ] Reset database with new schema: `npx prisma db push --force-reset`
5. [ ] Generate Prisma client: `npx prisma generate`
6. [ ] Update seed file with seedSiteStructure function
7. [ ] Run seed: `npx prisma db seed`
8. [ ] Verify all indexes are created correctly
9. [ ] Test foreign key relationships
10. [ ] Run performance tests on queries

### Post-Implementation
- [ ] Verify site structure is properly seeded
- [ ] Test URL resolution queries
- [ ] Test parent-child relationships
- [ ] Document any deviations from planned schema
- [ ] Create TypeScript types for SiteStructure if needed

## Success Metrics

- ✅ All database objects created successfully
- ✅ Indexes improve query performance to < 10ms
- ✅ Constraints prevent invalid data
- ✅ Schema supports all Epic 8 requirements
- ✅ Compatible with existing content management system

## Potential Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Migration fails on existing data | High | Test on copy of production first |
| Index creation slow on large datasets | Medium | Run during maintenance window |
| Generated column not supported | Low | Implement in application layer |
| Constraint violations on existing data | Medium | Data cleanup script before migration |

## Dependencies & Blockers

### Dependencies
- PostgreSQL 14+ (for gen_random_uuid())
- Prisma ORM configured
- Existing websites and content_items tables

### No Blockers Expected
This is the foundational story for Epic 8 with no dependencies on other Epic 8 stories.

## Definition of Done

- [ ] Prisma schema updated with SiteStructure model
- [ ] Database migration successfully applied
- [ ] All indexes created and verified
- [ ] Constraints working as expected
- [ ] Performance benchmarks met (< 10ms queries)
- [ ] Unit tests passing
- [ ] Integration tests passing
- [ ] Schema documented in database documentation
- [ ] Team notified of schema availability
- [ ] Ready for Story 8.2 (Slug Management System)

## Notes for Developer

### Important Reminders
1. **Use TEXT for full_path** - Not VARCHAR, per Sitecore expert recommendation
2. **Weight field is computed** - Don't set manually, it mirrors position
3. **Path depth starts at 0** - Root level is 0, not 1
4. **Cascade rules are critical** - ON DELETE CASCADE prevents orphans

### Performance Considerations
- The `full_path` index is critical for URL resolution
- Consider EXPLAIN ANALYZE on key queries after implementation
- Monitor index usage with pg_stat_user_indexes

### Next Stories
After this schema is implemented, the following stories can proceed:
- Story 8.2: Slug Management System (validation and generation)
- Story 8.4: Storage Layer CRUD Operations
- Story 8.5: Path Management Utilities

## Related Documents
- [Epic 8 PRD](../epic8-brownfield-prd.md)
- [Epic 8 Architecture](../epic8-brownfield-architecture.md)
- [Epic 8 Project Brief](../epic8-project-brief.md)

---

**Story Status**: Ready for Development
**Assigned To**: [Developer Name]
**Sprint**: [Current Sprint]
**Last Updated**: 2025-08-22