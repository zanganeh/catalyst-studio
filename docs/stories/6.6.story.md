# Story 6.6: Create Conflict Detection System

## Status
Approved

## Story
**As a** content manager,  
**I want to** know when content types have conflicting changes,  
**So that** I can resolve them before syncing

## Acceptance Criteria
1. Detect when same type modified in both systems
2. Show three-way diff (local, remote, common ancestor)
3. Flag conflicts for manual review
4. Provide conflict resolution strategies
5. All conflict detection operations are properly unit tested

## Tasks / Subtasks
- [x] Git Setup (REQUIRED FIRST TASK)
  - [x] Checkout and update main: `git checkout main && git pull origin main`
  - [x] Create feature branch: `git checkout -b feature/epic6-conflict-detection`
- [x] Build Conflict Detection Engine (AC: 1, 2)
  - [x] Create `conflict-detector.js` in proof-of-concept directory
  - [x] Import ChangeDetector from Story 6.5
  - [x] Import VersionHistory from Story 6.3
  - [x] Implement `detectConflicts()` method for concurrent modifications
  - [x] Create `findCommonAncestor()` using version history
  - [x] Add unit tests for conflict detection scenarios
- [x] Implement Three-Way Diff (AC: 2)
  - [x] Create `ThreeWayDiff` class for comparison
  - [x] Implement `compareVersions()` for local vs remote vs ancestor
  - [x] Generate field-level diff information
  - [x] Format diff output for UI display
  - [x] Test three-way diff with various scenarios
- [x] Create Conflict Flagging System (AC: 3)
  - [x] Add `ConflictManager` class
  - [x] Implement `flagForReview()` method
  - [x] Create conflict queue for manual review
  - [x] Store conflict metadata in database
  - [x] Add conflict status to sync state
  - [x] Test conflict flagging workflow
- [x] Build Resolution Strategy Engine (AC: 4)
  - [x] Create `ResolutionStrategy` interface
  - [x] Implement `LocalWins` strategy (prefer local changes)
  - [x] Implement `RemoteWins` strategy (prefer remote changes)
  - [x] Implement `ManualMerge` strategy (require user input)
  - [x] Add `AutoMerge` for non-conflicting field changes
  - [x] Test each resolution strategy
- [x] Integrate with Sync State (AC: 1, 3)
  - [x] Update SyncState table with conflict_status field
  - [x] Create Prisma migration for schema changes
  - [x] Store conflict details in database
  - [x] Track resolution history
  - [x] Test database persistence
- [x] Create Conflict Resolution API (AC: 3, 4)
  - [x] Create `/app/api/v1/sync/conflicts/route.ts`
  - [x] Implement GET endpoint for conflict list
  - [x] Implement POST endpoint for resolution
  - [x] Return conflict details with diff data
  - [x] Test API endpoints
- [x] Connect to Deployment Service (AC: 1, 3)
  - [x] Update deployment-service.ts to check for conflicts
  - [x] Halt sync if conflicts detected
  - [x] Provide conflict resolution options
  - [x] Allow continuation after resolution
  - [x] Test integration with deployment flow
- [ ] Submit PR (REQUIRED FINAL TASK)
  - [ ] Push branch: `git push -u origin feature/epic6-conflict-detection`
  - [ ] Create PR from feature branch → main branch
  - [ ] PR Title: "feat(sync): add conflict detection with three-way diff"
  - [ ] Link PR to story in description

## Dev Notes

### GitFlow Workflow
Branch Name: feature/epic6-conflict-detection
Base Branch: main
PR Target: main

Git Commands:
1. Setup: `git checkout main && git pull origin main`
2. Create: `git checkout -b feature/epic6-conflict-detection`
3. Commit: Use conventional commits - `git commit -m "feat(sync): add conflict detection with three-way diff"`
4. Push: `git push -u origin feature/epic6-conflict-detection`
5. PR: Create PR to main branch with title "feat(sync): add conflict detection with three-way diff"

### Previous Story Insights
[Source: Story 6.5 Dev Agent Record]
- ChangeDetector successfully implemented in `/lib/sync/detection/ChangeDetector.ts`
- Native TypeScript implementation working correctly (no more PoC import issues)
- SyncState table created with proper tracking of local/remote hashes
- Deployment service integration complete with proper error handling
- Testing pattern: Jest tests in `__tests__` folders adjacent to source files
- Performance: Fast change detection (<100ms for typical operations)

[Source: Story 6.3 Dev Agent Record]
- Version history system implemented with Merkle tree structure
- ContentTypeVersion table tracks full history with parent links
- VersionHistory class in `/lib/sync/versioning/VersionHistory.ts`
- Git-like branching support for concurrent modifications

### Technical Architecture Context
[Source: docs/epic6-architecture.md & Epic 6 PRD Conflict Detection]

**Conflict Detection Architecture**:
- Integration Point: Extends change detection from Story 6.5
- Location: Add to `/proof-of-concept/` directory initially, then migrate to TypeScript
- Three-way diff: Compare local, remote, and common ancestor versions
- Resolution strategies: Auto-merge for non-conflicting fields, manual for conflicts

**File Structure** (Building on existing):
```
/proof-of-concept/          # Initial implementation
├── change-detector.js      # EXISTING - From Story 6.5
├── conflict-detector.js    # NEW - This story
└── resolution-strategies.js # NEW - This story

/lib/sync/                  # Production TypeScript code
├── detection/
│   └── ChangeDetector.ts   # EXISTING - From Story 6.5
├── conflict/
│   ├── ConflictDetector.ts # NEW - TypeScript version
│   ├── ThreeWayDiff.ts     # NEW - Diff engine
│   └── ResolutionStrategy.ts # NEW - Strategy pattern
├── versioning/
│   ├── ContentTypeHasher.ts # EXISTING - From Story 6.2
│   └── VersionHistory.ts   # EXISTING - From Story 6.3
└── tracking/
    └── SyncHistoryManager.ts # EXISTING - From Story 6.4
```

### Database Schema
[Source: Epic 6 Architecture - Conflict Management]

**ConflictLog Table** (to be created):
```prisma
model ConflictLog {
  id              String   @id @default(cuid())
  typeKey         String   @map("type_key")
  localHash       String   @map("local_hash")
  remoteHash      String   @map("remote_hash")
  ancestorHash    String?  @map("ancestor_hash")
  conflictType    String   @map("conflict_type") // field/structure/delete
  conflictDetails Json     @map("conflict_details")
  resolution      String?  @map("resolution") // local_wins/remote_wins/merged/pending
  resolvedBy      String?  @map("resolved_by")
  resolvedAt      DateTime? @map("resolved_at")
  createdAt       DateTime @default(now()) @map("created_at")
  
  @@map("conflict_log")
  @@index([typeKey, createdAt])
}
```

**Update SyncState Table**:
```prisma
model SyncState {
  // ... existing fields ...
  conflictStatus  String?  @map("conflict_status") // none/detected/resolved
  lastConflictAt  DateTime? @map("last_conflict_at")
  // ... rest of fields ...
}
```

### Implementation Details
[Source: Epic 6 PRD - Story 6.6 & Architecture Conflict Resolution]

**Conflict Detector Implementation**:
```javascript
// /proof-of-concept/conflict-detector.js
class ConflictDetector {
  constructor(changeDetector, versionHistory) {
    this.changeDetector = changeDetector;
    this.versionHistory = versionHistory;
  }
  
  async detectConflicts(typeKey) {
    // Get current local and remote versions
    const localVersion = await this.versionHistory.getLatestVersion(typeKey, 'local');
    const remoteVersion = await this.versionHistory.getLatestVersion(typeKey, 'remote');
    
    // Find common ancestor
    const ancestor = await this.findCommonAncestor(localVersion, remoteVersion);
    
    // Check if both modified since ancestor
    if (localVersion.hash !== ancestor.hash && 
        remoteVersion.hash !== ancestor.hash) {
      return {
        hasConflict: true,
        type: this.determineConflictType(localVersion, remoteVersion, ancestor),
        details: this.generateConflictDetails(localVersion, remoteVersion, ancestor)
      };
    }
    
    return { hasConflict: false };
  }
  
  async findCommonAncestor(localVersion, remoteVersion) {
    // Traverse version tree to find common parent
    const localAncestors = await this.getAncestorChain(localVersion);
    const remoteAncestors = await this.getAncestorChain(remoteVersion);
    
    // Find first common hash
    for (const localAncestor of localAncestors) {
      if (remoteAncestors.find(r => r.hash === localAncestor.hash)) {
        return localAncestor;
      }
    }
    
    // If no common ancestor, use initial version
    return this.versionHistory.getInitialVersion(localVersion.typeKey);
  }
  
  generateThreeWayDiff(local, remote, ancestor) {
    return {
      localChanges: this.diffVersions(ancestor, local),
      remoteChanges: this.diffVersions(ancestor, remote),
      conflicts: this.identifyFieldConflicts(local, remote, ancestor)
    };
  }
}
```

**Resolution Strategies**:
```typescript
// /lib/sync/conflict/ResolutionStrategy.ts
interface ResolutionStrategy {
  name: string;
  canAutoResolve(conflict: Conflict): boolean;
  resolve(conflict: Conflict): Resolution;
}

class LocalWinsStrategy implements ResolutionStrategy {
  name = 'local_wins';
  
  canAutoResolve(conflict: Conflict): boolean {
    return conflict.type !== 'structural'; // Can't auto-resolve structural conflicts
  }
  
  resolve(conflict: Conflict): Resolution {
    return {
      winner: 'local',
      merged: conflict.local,
      changes: conflict.localChanges
    };
  }
}

class RemoteWinsStrategy implements ResolutionStrategy {
  name = 'remote_wins';
  
  canAutoResolve(conflict: Conflict): boolean {
    return conflict.type !== 'structural';
  }
  
  resolve(conflict: Conflict): Resolution {
    return {
      winner: 'remote',
      merged: conflict.remote,
      changes: conflict.remoteChanges
    };
  }
}

class AutoMergeStrategy implements ResolutionStrategy {
  name = 'auto_merge';
  
  canAutoResolve(conflict: Conflict): boolean {
    // Only if changes don't overlap
    return !this.hasOverlappingChanges(conflict);
  }
  
  resolve(conflict: Conflict): Resolution {
    // Merge non-conflicting field changes
    const merged = { ...conflict.ancestor };
    
    // Apply local changes
    for (const field of conflict.localChanges.modified) {
      if (!conflict.remoteChanges.modified.includes(field)) {
        merged[field] = conflict.local[field];
      }
    }
    
    // Apply remote changes
    for (const field of conflict.remoteChanges.modified) {
      if (!conflict.localChanges.modified.includes(field)) {
        merged[field] = conflict.remote[field];
      }
    }
    
    return { winner: 'merged', merged, changes: [...] };
  }
}
```

### API Endpoint Structure
[Source: Next.js 14 App Router pattern from Story 6.5]

```typescript
// /app/api/v1/sync/conflicts/route.ts
export async function GET(request: Request) {
  const detector = new ConflictDetector();
  const conflicts = await detector.getAllConflicts();
  
  return NextResponse.json({
    conflicts: conflicts.map(c => ({
      typeKey: c.typeKey,
      type: c.conflictType,
      localChanges: c.localChanges,
      remoteChanges: c.remoteChanges,
      suggestedResolution: c.suggestedStrategy
    }))
  });
}

export async function POST(request: Request) {
  const { typeKey, resolution } = await request.json();
  
  const resolver = new ConflictResolver();
  const result = await resolver.resolveConflict(typeKey, resolution);
  
  return NextResponse.json({
    success: true,
    resolved: result
  });
}
```

### Integration with Existing Components
[Source: Story 6.2, 6.3, 6.4, 6.5 implementations]

1. **ChangeDetector Integration**: Use to identify modified types
   ```typescript
   const detector = new ChangeDetector();
   const changes = await detector.detectChanges();
   // Check each modified type for conflicts
   for (const typeKey of changes.updated) {
     const conflict = await conflictDetector.detectConflicts(typeKey);
   }
   ```

2. **VersionHistory Integration**: Access version tree for ancestry
   ```typescript
   const history = new VersionHistory();
   const versions = await history.getVersionChain(typeKey);
   const ancestor = await history.findCommonAncestor(local, remote);
   ```

3. **SyncHistoryManager Integration**: Record conflict resolution
   ```typescript
   await syncHistoryManager.recordConflictResolution({
     typeKey: contentType.key,
     conflict: conflictDetails,
     resolution: strategy,
     resolvedBy: userId
   });
   ```

### Error Handling Pattern
[Source: Story 6.5 patterns]
```typescript
try {
  const conflicts = await conflictDetector.detectConflicts(typeKey);
  if (conflicts.hasConflict && !conflicts.canAutoResolve) {
    // Flag for manual review
    await conflictManager.flagForReview(typeKey, conflicts);
    // Don't stop the sync, continue with other types
  }
} catch (error) {
  console.error(`Conflict detection failed for ${typeKey}:`, error);
  await this.logError(error, 'CONFLICT_DETECTION_FAILED', typeKey);
  // Continue with next item
}
```

### Testing Standards
[Source: Story 6.5 patterns]

**Test Framework**: Jest (already configured)
**Test Location**: Adjacent `__tests__` folders for TypeScript, same directory for JavaScript PoC files
**Coverage Target**: Minimum 80% code coverage for conflict detection logic

**Required Test Scenarios**:
```javascript
// /proof-of-concept/conflict-detector.test.js
describe('ConflictDetector', () => {
  it('should detect concurrent modifications', async () => {
    // Setup: Same type modified in both local and remote
    // Run detectConflicts()
    // Assert: conflict detected with correct type
  });
  
  it('should find common ancestor', async () => {
    // Setup: Version tree with known ancestry
    // Run findCommonAncestor()
    // Assert: correct ancestor identified
  });
  
  it('should generate three-way diff', async () => {
    // Setup: Local, remote, and ancestor versions
    // Run generateThreeWayDiff()
    // Assert: correct diff for each comparison
  });
  
  it('should identify field-level conflicts', async () => {
    // Setup: Same field modified differently
    // Run conflict detection
    // Assert: field conflict identified
  });
  
  it('should auto-merge non-conflicting changes', async () => {
    // Setup: Different fields modified
    // Run AutoMergeStrategy
    // Assert: successful merge
  });
  
  it('should require manual resolution for structural conflicts', async () => {
    // Setup: Structural changes in both versions
    // Run conflict detection
    // Assert: flagged for manual review
  });
});
```

### Performance Considerations
[Source: Epic 6 Architecture & PRD]
- Cache ancestor lookups to avoid repeated tree traversal
- Use efficient diff algorithms (Myers' diff algorithm)
- Batch conflict detection for multiple types
- Implement pagination for large conflict lists

### MVP Focus
[Source: Epic 6 PRD - MVP Context]
**Required for MVP**:
- Basic conflict detection for concurrent modifications
- Simple three-way diff display
- Manual conflict flagging
- Basic resolution strategies (local wins, remote wins)

**Not Required for MVP**:
- Complex auto-merge algorithms
- Field-level merge UI
- Conflict prediction
- Automated conflict resolution for all cases

### Dependencies
[Source: Current package.json & previous stories]
- **Prisma**: Already installed
- **ChangeDetector**: Already implemented in Story 6.5
- **VersionHistory**: Already implemented in Story 6.3
- **diff**: May need to install for three-way diff (npm install diff)
- No other new npm packages required

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-18 | 1.0 | Initial story creation based on Epic 6 PRD and architecture | Scrum Master (Bob) |

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
claude-opus-4-1-20250805

### Debug Log References
No debug log entries needed - all tasks completed successfully

### Completion Notes List
- Successfully implemented conflict detection system with three-way diff capability
- Created both JavaScript proof-of-concept and TypeScript production implementations
- Integrated conflict detection into deployment service with automatic halting on conflicts
- Added comprehensive test suites for all components
- Created database schema and Prisma migrations for conflict persistence
- Implemented multiple resolution strategies (local wins, remote wins, auto-merge, manual)
- Added REST API endpoints for conflict management

### File List
**New Files Created:**
- `/proof-of-concept/conflict-detector.js` - JavaScript conflict detection implementation
- `/proof-of-concept/conflict-detector.test.js` - Tests for conflict detector
- `/proof-of-concept/three-way-diff.js` - Three-way diff implementation
- `/proof-of-concept/three-way-diff.test.js` - Tests for three-way diff
- `/proof-of-concept/conflict-manager.js` - Conflict flagging and management
- `/proof-of-concept/conflict-manager.test.js` - Tests for conflict manager
- `/proof-of-concept/resolution-strategies.js` - Resolution strategy implementations
- `/proof-of-concept/resolution-strategies.test.js` - Tests for resolution strategies
- `/lib/sync/conflict/ConflictDetector.ts` - TypeScript conflict detector
- `/lib/sync/conflict/ThreeWayDiff.ts` - TypeScript three-way diff
- `/lib/sync/conflict/ConflictManager.ts` - TypeScript conflict manager
- `/lib/sync/conflict/ResolutionStrategy.ts` - TypeScript resolution strategies
- `/app/api/v1/sync/conflicts/route.ts` - Conflict resolution API endpoints

**Modified Files:**
- `/prisma/schema.prisma` - Added ConflictLog model and updated SyncState
- `/prisma/migrations/20250817235751_add_conflict_detection_tables/migration.sql` - Migration for conflict tables
- `/lib/services/deployment-service.ts` - Integrated conflict detection into deployment flow

## QA Results
_This section will be populated by the QA agent after implementation review_