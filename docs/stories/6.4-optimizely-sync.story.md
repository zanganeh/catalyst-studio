# Story 6.4: Track Pushed/Synced Data

## Status
Ready for Development

## Story
**As a** system administrator,  
**I want to** track all data pushed to external systems,  
**So that** I have a complete audit trail of synchronizations

## Acceptance Criteria
1. Store snapshot of data sent to external system
2. Record sync timestamp and target platform
3. Track sync status (success/failure/partial)
4. Link sync records to version history
5. Maintain bidirectional sync tracking (push/pull)
6. Support querying sync history by various filters
7. Generate sync reports and analytics
8. All sync operations are properly unit tested

## Tasks / Subtasks
- [ ] Git Setup (REQUIRED FIRST TASK)
  - [ ] Checkout and update main: `git checkout main && git pull origin main`
  - [ ] Create feature branch: `git checkout -b feature/6-4-sync-tracking`
- [ ] Create Database Schema for Sync History (AC: 1, 2, 3, 5)
  - [ ] Add sync_history table to Prisma schema
  - [ ] Include fields for type_key, version_hash, target_platform, sync_direction
  - [ ] Add sync_status, pushed_data, response_data fields
  - [ ] Add error_message, retry_count, and sync metadata
  - [ ] Create indexes for efficient querying
  - [ ] Run migration to update database structure
- [ ] Integrate with ContentTypeHasher (AC: 4)
  - [ ] Import ContentTypeHasher from `/lib/sync/versioning/ContentTypeHasher.ts`
  - [ ] Add `getVersionHash()` method to SyncHistoryManager
  - [ ] Ensure hash consistency across sync operations
  - [ ] Test version hash generation for different content types
- [ ] Implement SyncHistoryManager Class (AC: 1, 2, 3, 4)
  - [ ] Create `/lib/sync/tracking/SyncHistoryManager.ts`
  - [ ] Implement `recordSyncAttempt()` method to track sync initiation
  - [ ] Implement `updateSyncStatus()` to update sync result
  - [ ] Add `linkToVersion()` to connect sync with version history
  - [ ] Create `getSyncHistory()` with filtering options
  - [ ] Add retry tracking and failure analysis methods
  - [ ] Implement retry strategy with exponential backoff
- [ ] Create SyncSnapshot Service (AC: 1)
  - [ ] Create `/lib/sync/tracking/SyncSnapshot.ts`
  - [ ] Implement `captureSnapshot()` to store pre-sync data state
  - [ ] Add `compareSnapshots()` for diff analysis
  - [ ] Create compression for large snapshots
  - [ ] Support multiple snapshot formats (JSON, compressed)
- [ ] Enhance Optimizely API Client with Tracking (AC: 2, 3)
  - [ ] Update `/lib/sync/adapters/optimizely-api-client.ts`
  - [ ] Add sync tracking hooks before API calls
  - [ ] Capture response data and status codes
  - [ ] Implement error tracking with detailed messages
  - [ ] Add timing metrics for sync operations
- [ ] Implement Sync Analytics Service (AC: 6, 7)
  - [ ] Create `/lib/sync/tracking/SyncAnalytics.ts`
  - [ ] Implement success/failure rate calculations
  - [ ] Add average sync time analytics
  - [ ] Create failure pattern detection
  - [ ] Generate sync health reports
- [ ] Add Sync History API Endpoints (AC: 6, 7)
  - [ ] Create `/app/api/v1/sync/history/route.ts`
  - [ ] Implement GET endpoint with query filters
  - [ ] Create `/app/api/v1/sync/[syncId]/route.ts` for individual sync details
  - [ ] Create `/app/api/v1/sync/[syncId]/status/route.ts` for real-time status polling
  - [ ] Add `/app/api/v1/sync/analytics/route.ts` for sync metrics
  - [ ] Create `/app/api/v1/sync/[typeKey]/history/route.ts` for type-specific history
- [ ] Update Deployment Service Integration (AC: 2, 3, 4)
  - [ ] Modify `/lib/services/deployment-service.ts`
  - [ ] Add sync history recording to deployment flow
  - [ ] Link deployment records with sync history
  - [ ] Update deployment status based on sync results
  - [ ] Add rollback tracking capabilities
- [ ] Create Sync Status Dashboard Components (AC: 7)
  - [ ] Create `/components/sync/SyncHistoryTable.tsx`
  - [ ] Implement sync status indicators
  - [ ] Add filtering and sorting capabilities
  - [ ] Create sync timeline visualization
  - [ ] Add export functionality for reports
- [ ] Add Unit Tests (AC: 8)
  - [ ] Create `/lib/sync/tracking/__tests__/SyncHistoryManager.test.ts`
  - [ ] Test sync recording and status updates
  - [ ] Test version linking functionality
  - [ ] Create `/lib/sync/tracking/__tests__/SyncSnapshot.test.ts`
  - [ ] Test snapshot capture and comparison
  - [ ] Create `/lib/sync/tracking/__tests__/SyncAnalytics.test.ts`
  - [ ] Test metrics calculation and reporting
  - [ ] Add integration tests for complete sync tracking flow
- [ ] Integration Testing
  - [ ] Test end-to-end sync tracking with Optimizely
  - [ ] Verify sync history is properly recorded
  - [ ] Test failure scenarios and retry logic
  - [ ] Validate analytics calculations
  - [ ] Test API endpoints with various filters
- [ ] Submit PR (REQUIRED FINAL TASK)
  - [ ] Push branch: `git push -u origin feature/6-4-sync-tracking`
  - [ ] Create PR from feature branch → main branch
  - [ ] PR Title: "Epic 6 Story 4: Track Pushed/Synced Data"
  - [ ] Link PR to story in description

## Dev Notes

### GitFlow Workflow
Branch Name: feature/6-4-sync-tracking  
Base Branch: main  
PR Target: main  

Git Commands:
1. Setup: `git checkout main && git pull origin main`
2. Create: `git checkout -b feature/6-4-sync-tracking`
3. Commit: Use conventional commits (feat:, fix:, docs:, etc.)
4. Push: `git push -u origin feature/6-4-sync-tracking`
5. PR: Create PR to main branch with title "Epic 6 Story 4: Track Pushed/Synced Data"

### Source Tree Context
[Source: Story 6.3 Implementation & Epic 6 Architecture]

**Existing Sync Structure** (from current implementation):
```
/lib/sync/
├── adapters/
│   └── optimizely-api-client.ts    # Optimizely API integration
├── transformers/
│   └── optimizely-transformer.ts   # Data transformation logic
└── versioning/                     # Version tracking from Story 6.2-6.3
    ├── ContentTypeHasher.ts
    ├── VersionHistoryManager.ts
    ├── VersionTree.ts
    └── VersionDiff.ts
```

**New Additions for Story 6.4**:
```
/lib/sync/tracking/
├── SyncHistoryManager.ts      # NEW - Sync history tracking
├── SyncSnapshot.ts            # NEW - Snapshot management
├── SyncAnalytics.ts          # NEW - Analytics and reporting
└── __tests__/
    ├── SyncHistoryManager.test.ts
    ├── SyncSnapshot.test.ts
    └── SyncAnalytics.test.ts

/app/api/v1/sync/             # NEW - Sync API endpoints
├── history/
│   └── route.ts
├── [syncId]/
│   └── route.ts
├── analytics/
│   └── route.ts
└── [typeKey]/
    └── history/
        └── route.ts

/components/sync/             # NEW - Sync UI components
└── SyncHistoryTable.tsx
```

### Database Schema Design
[Source: Epic 6 PRD - Section 6.4 & Existing Deployment Table]

**New Table for Sync History**:
```prisma
model SyncHistory {
  id              String   @id @default(cuid())
  typeKey         String   @map("type_key")
  versionHash     String   @map("version_hash")
  targetPlatform  String   @map("target_platform")
  syncDirection   String   @map("sync_direction") // PUSH or PULL
  syncStatus      String   @map("sync_status")    // SUCCESS, FAILED, PARTIAL, IN_PROGRESS
  pushedData      Json     @map("pushed_data")    // Snapshot of sent data
  responseData    Json?    @map("response_data")   // Platform response
  errorMessage    String?  @map("error_message")
  retryCount      Int      @default(0) @map("retry_count")
  syncMetadata    Json?    @map("sync_metadata")  // Additional tracking data
  deploymentId    String?  @map("deployment_id")  // Link to deployment
  startedAt       DateTime @map("started_at")
  completedAt     DateTime? @map("completed_at")
  createdAt       DateTime @default(now()) @map("created_at")
  
  // Relations
  version    ContentTypeVersion? @relation(fields: [versionHash], references: [versionHash])
  deployment Deployment?         @relation(fields: [deploymentId], references: [id])
  
  @@index([typeKey, createdAt])
  @@index([versionHash])
  @@index([targetPlatform])
  @@index([syncStatus])
  @@index([deploymentId])
  @@map("sync_history")
}

// Update to Deployment model to add bidirectional relation:
model Deployment {
  // ... existing fields ...
  syncHistory SyncHistory[]  // Add this relation field
}
```

### Technical Implementation Details
[Source: Epic 6 PRD - Section 7.2 Sync Tracking & Epic 6 Architecture]

**SyncHistoryManager Class Structure**:
```typescript
// /lib/sync/tracking/SyncHistoryManager.ts
import { ContentTypeHasher } from '../versioning/ContentTypeHasher';

// Retry Strategy Configuration
interface RetryConfig {
  maxAttempts: number;
  backoffMultiplier: number;
  initialDelayMs: number;
  maxDelayMs: number;
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxAttempts: 3,
  backoffMultiplier: 2,
  initialDelayMs: 1000,  // 1 second
  maxDelayMs: 30000      // 30 seconds max
};

export class SyncHistoryManager {
  private hasher: ContentTypeHasher;
  private retryConfig: RetryConfig;
  
  constructor(
    private prisma: PrismaClient,
    retryConfig: Partial<RetryConfig> = {}
  ) {
    this.hasher = new ContentTypeHasher();
    this.retryConfig = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };
  }
  
  async getVersionHash(contentType: any): Promise<string> {
    // Use ContentTypeHasher from Story 6.2
    return this.hasher.generateHash(contentType);
  }
  
  async executeWithRetry<T>(
    operation: () => Promise<T>,
    syncId: string
  ): Promise<T> {
    let lastError: Error | undefined;
    
    for (let attempt = 1; attempt <= this.retryConfig.maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        // Update retry count in database
        await this.prisma.syncHistory.update({
          where: { id: syncId },
          data: { retryCount: attempt }
        });
        
        if (attempt < this.retryConfig.maxAttempts) {
          // Calculate delay with exponential backoff
          const delay = Math.min(
            this.retryConfig.initialDelayMs * Math.pow(this.retryConfig.backoffMultiplier, attempt - 1),
            this.retryConfig.maxDelayMs
          );
          
          console.log(`Sync attempt ${attempt} failed, retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError;
  }
  
  async recordSyncAttempt(params: {
    typeKey: string;
    versionHash: string;
    targetPlatform: string;
    syncDirection: 'PUSH' | 'PULL';
    data: any;
    deploymentId?: string;
  }): Promise<string> {
    // Create sync history record
    // Capture snapshot of data being synced
    // Return sync ID for tracking
  }
  
  async updateSyncStatus(syncId: string, status: SyncStatus, response?: any, error?: Error): Promise<void> {
    // Update sync record with result
    // Store response data or error details
    // Calculate completion time
  }
  
  async linkToVersion(syncId: string, versionHash: string): Promise<void> {
    // Connect sync record to version history
    // Enables traceability between versions and syncs
  }
  
  async getSyncHistory(filters: SyncHistoryFilters): Promise<SyncRecord[]> {
    // Query sync history with filters
    // Support filtering by date, status, platform, etc.
  }
  
  async getLastSuccessfulSync(typeKey: string, platform: string): Promise<SyncRecord | null> {
    // Find most recent successful sync for type
    // Used for incremental sync strategies
  }
}

interface SyncHistoryFilters {
  typeKey?: string;
  targetPlatform?: string;
  syncStatus?: SyncStatus;
  dateRange?: { start: Date; end: Date };
  deploymentId?: string;
}

enum SyncStatus {
  SUCCESS = 'SUCCESS',
  FAILED = 'FAILED',
  PARTIAL = 'PARTIAL',
  IN_PROGRESS = 'IN_PROGRESS'
}
```

**SyncSnapshot Implementation**:
```typescript
// /lib/sync/tracking/SyncSnapshot.ts
import { gzip, gunzip } from 'zlib';
import { promisify } from 'util';
import { createHash } from 'crypto';

const gzipAsync = promisify(gzip);
const gunzipAsync = promisify(gunzip);

// Compression Configuration
const COMPRESSION_THRESHOLD = 100_000;  // 100KB - compress if larger
const MAX_SNAPSHOT_SIZE = 10_000_000;   // 10MB - maximum allowed size
const COMPRESSION_LEVEL = 6;            // zlib compression level (1-9)

export class SyncSnapshot {
  async captureSnapshot(data: any): Promise<string> {
    // Serialize data to JSON
    const jsonString = JSON.stringify(data);
    const sizeInBytes = Buffer.byteLength(jsonString, 'utf8');
    
    // Check size limit
    if (sizeInBytes > MAX_SNAPSHOT_SIZE) {
      throw new Error(`Snapshot size (${sizeInBytes} bytes) exceeds maximum allowed size (${MAX_SNAPSHOT_SIZE} bytes)`);
    }
    
    // Calculate checksum for integrity
    const checksum = createHash('sha256').update(jsonString).digest('hex');
    
    // Compress if over threshold
    let finalData: string;
    let isCompressed = false;
    
    if (sizeInBytes > COMPRESSION_THRESHOLD) {
      const compressed = await gzipAsync(jsonString, { level: COMPRESSION_LEVEL });
      finalData = compressed.toString('base64');
      isCompressed = true;
      
      console.log(`Snapshot compressed: ${sizeInBytes} bytes → ${compressed.length} bytes (${Math.round((1 - compressed.length / sizeInBytes) * 100)}% reduction)`);
    } else {
      finalData = jsonString;
    }
    
    // Return snapshot with metadata
    return JSON.stringify({
      data: finalData,
      checksum,
      isCompressed,
      originalSize: sizeInBytes,
      timestamp: new Date().toISOString()
    });
  }
  
  async compareSnapshots(snapshot1: string, snapshot2: string): Promise<SnapshotDiff> {
    // Decompress if needed
    // Calculate differences between snapshots
    // Return structured diff
  }
  
  async validateSnapshot(snapshot: string, checksum: string): Promise<boolean> {
    // Verify snapshot integrity
    // Used to ensure data consistency
  }
}

interface SnapshotDiff {
  added: any[];
  modified: any[];
  removed: any[];
  unchanged: number;
}
```

**SyncAnalytics Service**:
```typescript
// /lib/sync/tracking/SyncAnalytics.ts
export class SyncAnalytics {
  constructor(private prisma: PrismaClient) {}
  
  async calculateSuccessRate(platform: string, timeRange: TimeRange): Promise<number> {
    // Calculate percentage of successful syncs
  }
  
  async getAverageSyncTime(platform: string): Promise<number> {
    // Calculate average duration of syncs
  }
  
  async detectFailurePatterns(): Promise<FailurePattern[]> {
    // Analyze failed syncs for patterns
    // Identify common error types
  }
  
  async generateHealthReport(platform: string): Promise<HealthReport> {
    // Comprehensive sync health metrics
    // Include success rates, timing, errors
  }
}

interface HealthReport {
  platform: string;
  successRate: number;
  averageDuration: number;
  recentFailures: number;
  commonErrors: string[];
  recommendations: string[];
}
```

### Integration Points
[Source: Story 6.3 Implementation & Current Sync Implementation]

**Optimizely API Client Enhancement**:
```typescript
// Update existing optimizely-api-client.ts
class OptimizelyApiClient {
  private syncHistoryManager: SyncHistoryManager;
  
  async pushContentType(contentType: OptimizelyContentType): Promise<void> {
    // Record sync attempt
    const syncId = await this.syncHistoryManager.recordSyncAttempt({
      typeKey: contentType.key,
      versionHash: await this.getVersionHash(contentType),
      targetPlatform: 'optimizely',
      syncDirection: 'PUSH',
      data: contentType
    });
    
    try {
      // Existing push logic
      const response = await this.apiCall(contentType);
      
      // Update sync status on success
      await this.syncHistoryManager.updateSyncStatus(syncId, SyncStatus.SUCCESS, response);
    } catch (error) {
      // Update sync status on failure
      await this.syncHistoryManager.updateSyncStatus(syncId, SyncStatus.FAILED, null, error);
      throw error;
    }
  }
}
```

**Deployment Service Integration**:
```typescript
// Update deployment-service.ts to track syncs
export class DeploymentService {
  async deployToProvider(deploymentId: string, contentTypes: ContentType[]): Promise<void> {
    for (const contentType of contentTypes) {
      // Track each sync operation
      await this.syncHistoryManager.recordSyncAttempt({
        typeKey: contentType.key,
        versionHash: contentType.versionHash,
        targetPlatform: this.provider,
        syncDirection: 'PUSH',
        data: contentType,
        deploymentId // Link to deployment
      });
    }
  }
}
```

### API Endpoint Structure (Next.js 14 App Router)
```typescript
// /app/api/v1/sync/history/route.ts
export async function GET(request: Request) {
  const url = new URL(request.url);
  const typeKey = url.searchParams.get('typeKey');
  const platform = url.searchParams.get('platform');
  const status = url.searchParams.get('status');
  const startDate = url.searchParams.get('startDate');
  const endDate = url.searchParams.get('endDate');
  
  const syncManager = new SyncHistoryManager(prisma);
  const history = await syncManager.getSyncHistory({
    typeKey,
    targetPlatform: platform,
    syncStatus: status as SyncStatus,
    dateRange: startDate && endDate ? { 
      start: new Date(startDate), 
      end: new Date(endDate) 
    } : undefined
  });
  
  return NextResponse.json(history);
}

// /app/api/v1/sync/analytics/route.ts
export async function GET(request: Request) {
  const url = new URL(request.url);
  const platform = url.searchParams.get('platform') || 'optimizely';
  
  const analytics = new SyncAnalytics(prisma);
  const report = await analytics.generateHealthReport(platform);
  
  return NextResponse.json(report);
}
```

### Important Notes from Previous Stories
[Source: Story 6.2 & 6.3 Dev Agent Records]

1. **Version Tracking Integration**: Sync records must link to version hashes from Story 6.2
2. **Merkle Tree Compatibility**: Sync history should work with version tree from Story 6.3
3. **Error Handling Pattern**: Use same pattern as established in Story 6.3:
   ```typescript
   try {
     // Sync operations
   } catch (error) {
     console.error(`Sync failed for ${typeKey}:`, error);
     await this.logError(error, 'SYNC_FAILED', typeKey);
     // Don't stop the process, continue with next item
   }
   ```
4. **Testing Pattern**: Jest tests in `__tests__` folders adjacent to source
5. **Database Migrations**: Use Prisma migrations for schema changes

### Real-time Status Updates
[Source: MVP Scope & Technical Constraints]

**Status Update Mechanism**:
For MVP, we'll use a **polling-based approach** with status endpoints:
- UI polls `/api/v1/sync/[syncId]/status` every 2 seconds during active sync
- Status endpoint returns current state from database
- Client-side React hooks manage polling lifecycle

```typescript
// Example status polling hook for UI
export function useSyncStatus(syncId: string) {
  const [status, setStatus] = useState<SyncStatus>('IN_PROGRESS');
  
  useEffect(() => {
    if (!syncId) return;
    
    const interval = setInterval(async () => {
      const response = await fetch(`/api/v1/sync/${syncId}/status`);
      const data = await response.json();
      setStatus(data.status);
      
      // Stop polling when sync completes
      if (data.status !== 'IN_PROGRESS') {
        clearInterval(interval);
      }
    }, 2000); // Poll every 2 seconds
    
    return () => clearInterval(interval);
  }, [syncId]);
  
  return status;
}
```

**Future Enhancement** (Post-MVP):
- WebSocket integration for real-time push updates
- Server-Sent Events (SSE) for unidirectional updates
- Progress percentage tracking for long-running syncs

### MVP Considerations
[Source: Epic 6 PRD - MVP Context]

**Focus Areas**:
- Basic sync tracking with success/failure status
- Simple snapshot storage (JSON format with compression for large data)
- Essential analytics (success rate, average time)
- API endpoints for history retrieval
- Link to existing version system
- Polling-based status updates (2-second intervals)
- Retry logic with exponential backoff (max 3 attempts)

**Not Required for MVP**:
- WebSocket real-time monitoring (use polling instead)
- Predictive failure analysis
- Automated sync rollback
- Advanced compression algorithms (using standard gzip)
- Complex retry strategies beyond exponential backoff

### Testing Standards
[Source: Story 6.2 & 6.3 patterns]

**Test Framework**: Jest (already configured)
**Test Location**: `/lib/sync/tracking/__tests__/`

**Example Test Cases**:
```typescript
// SyncHistoryManager.test.ts
describe('SyncHistoryManager', () => {
  it('should record sync attempt with snapshot', async () => {
    // Create sync record
    // Verify snapshot captured
    // Check all fields populated
  });
  
  it('should update sync status on completion', async () => {
    // Record attempt
    // Update with success
    // Verify timing and status
  });
  
  it('should link sync to version history', async () => {
    // Create version
    // Record sync
    // Verify linkage established
  });
  
  it('should handle partial sync failures', async () => {
    // Record multi-item sync
    // Mark as partial failure
    // Verify error details captured
  });
});

// SyncAnalytics.test.ts
describe('SyncAnalytics', () => {
  it('should calculate accurate success rate', async () => {
    // Create mix of successful and failed syncs
    // Calculate rate
    // Verify percentage correct
  });
  
  it('should identify failure patterns', async () => {
    // Create syncs with common errors
    // Run pattern detection
    // Verify patterns identified
  });
});
```

### Dependencies
[Source: Epic 6 Architecture & Current Implementation]
- **Prisma**: Already installed and configured
- **p-limit**: Already used in optimizely-api-client.ts
- **Next.js**: Already configured for API routes
- No new npm packages required for this story

### UI Component Structure
```typescript
// /components/sync/SyncHistoryTable.tsx
export function SyncHistoryTable({ typeKey }: { typeKey?: string }) {
  // Fetch sync history
  // Display in table format
  // Show status indicators
  // Support filtering and sorting
  // Export functionality
}

// Status indicators:
// ✅ SUCCESS - Green
// ❌ FAILED - Red  
// ⚠️ PARTIAL - Yellow
// 🔄 IN_PROGRESS - Blue
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-17 | 1.0 | Initial story creation based on Epic 6 PRD and Story 6.3 context | Scrum Master (Bob) |
| 2025-01-17 | 1.1 | Applied PO validation feedback: Added version hash integration, retry strategy, compression config, status polling mechanism | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
[To be filled when implementation starts]

### Debug Log References
[To be filled during implementation]

### Completion Notes List
[To be filled after implementation]

### File List
**New Files to Create:**
- `/lib/sync/tracking/SyncHistoryManager.ts`
- `/lib/sync/tracking/SyncSnapshot.ts`
- `/lib/sync/tracking/SyncAnalytics.ts`
- `/lib/sync/tracking/__tests__/SyncHistoryManager.test.ts`
- `/lib/sync/tracking/__tests__/SyncSnapshot.test.ts`
- `/lib/sync/tracking/__tests__/SyncAnalytics.test.ts`
- `/app/api/v1/sync/history/route.ts`
- `/app/api/v1/sync/[syncId]/route.ts`
- `/app/api/v1/sync/analytics/route.ts`
- `/app/api/v1/sync/[typeKey]/history/route.ts`
- `/components/sync/SyncHistoryTable.tsx`
- `/prisma/migrations/[timestamp]_add_sync_history/migration.sql`

**Files to Modify:**
- `/prisma/schema.prisma`
- `/lib/sync/adapters/optimizely-api-client.ts`
- `/lib/services/deployment-service.ts`

## QA Results
[To be filled after QA testing]